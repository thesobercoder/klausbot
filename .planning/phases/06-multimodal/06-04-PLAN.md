---
phase: 06-multimodal
plan: 04
type: execute
wave: 3
depends_on: ["06-03"]
files_modified:
  - src/telegram/bot.ts
  - src/daemon/gateway.ts
  - src/daemon/index.ts
autonomous: true

must_haves:
  truths:
    - "Voice messages are downloaded and queued with media attachment"
    - "Photo messages are downloaded and queued with media attachment"
    - "Multiple photos in one message all processed"
    - "Capability status logged at gateway startup"
  artifacts:
    - path: "src/telegram/bot.ts"
      provides: "hydrateFiles plugin applied"
      contains: "hydrateFiles"
    - path: "src/daemon/gateway.ts"
      provides: "Voice and photo handlers"
      contains: "message:voice"
    - path: "src/daemon/index.ts"
      provides: "MediaAttachment type re-export"
      contains: "MediaAttachment"
  key_links:
    - from: "src/daemon/gateway.ts"
      to: "src/media/index.ts"
      via: "downloadFile import"
      pattern: "downloadFile"
    - from: "src/telegram/bot.ts"
      to: "@grammyjs/files"
      via: "hydrateFiles plugin"
      pattern: "hydrateFiles"
---

<objective>
Add Telegram handlers for voice and photo messages.

Purpose: Complete the media pipeline by wiring Telegram message types to the queue.
Output: Voice and photo messages processed like text messages.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-multimodal/06-CONTEXT.md
@.planning/phases/06-multimodal/06-RESEARCH.md
@.planning/phases/06-multimodal/06-03-SUMMARY.md
@src/telegram/bot.ts
@src/daemon/gateway.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Apply hydrateFiles plugin to bot</name>
  <files>src/telegram/bot.ts</files>
  <action>
Read current `src/telegram/bot.ts`.

Add import at top:

```typescript
import { hydrateFiles } from "@grammyjs/files";
```

After the existing `autoRetry` config.use line (around line 18), add:

```typescript
// Enable file download helper methods
bot.api.config.use(hydrateFiles(config.TELEGRAM_BOT_TOKEN));
```

This adds the `.download()` method to File objects returned by `bot.api.getFile()`.
</action>
<verify>

1. `npx tsc --noEmit` passes
2. `grep "hydrateFiles" src/telegram/bot.ts` shows import and usage
   </verify>
   <done>

- hydrateFiles plugin applied to bot API config
- File objects now have .download() method
  </done>
  </task>

<task type="auto">
  <name>Task 2: Voice and photo message handlers in gateway</name>
  <files>src/daemon/gateway.ts</files>
  <action>
Read current `src/daemon/gateway.ts`.

Add to existing media imports (from Plan 03):

```typescript
import { downloadFile, isTranscriptionAvailable } from "../media/index.js";
import os from "os";
import path from "path";
```

In `startGateway()`, after the line `initializeEmbeddings();`, add capability logging:

```typescript
// Log media capabilities
log.info(
  {
    voiceTranscription: isTranscriptionAvailable(),
    imageAnalysis: true, // Always available (Claude vision)
  },
  "Media capabilities",
);
```

Find the `bot.on('message', ...)` handler that currently rejects non-text messages (around line 147).
REPLACE the entire catch-all handler with specific handlers for voice, photo, and truly unsupported types:

```typescript
// Voice message handler
bot.on("message:voice", async (ctx: MyContext) => {
  const chatId = ctx.chat?.id;
  if (!chatId) return;

  const voice = ctx.message.voice;
  if (!voice) return;

  log.info(
    { chatId, fileId: voice.file_id, duration: voice.duration },
    "Received voice message",
  );

  // Download voice file to temp location
  const tempPath = path.join(os.tmpdir(), `klausbot-voice-${Date.now()}.ogg`);

  try {
    const file = await ctx.api.getFile(voice.file_id);
    await file.download(tempPath);

    const media: MediaAttachment[] = [
      {
        type: "voice",
        fileId: voice.file_id,
        localPath: tempPath,
        mimeType: voice.mime_type,
      },
    ];

    // Get caption if any (voice messages can have captions)
    const text = ""; // Voice messages don't have captions in Telegram

    const queueId = queue.add(chatId, text, media);
    log.info({ chatId, queueId, mediaCount: 1 }, "Voice message queued");

    processQueue().catch((err) => {
      log.error({ err }, "Queue processing error");
    });
  } catch (err) {
    const msg = err instanceof Error ? err.message : String(err);
    log.error({ err, chatId }, "Failed to download voice message");
    await ctx.reply(`Failed to process voice message: ${msg}`);
  }
});

// Photo message handler
bot.on("message:photo", async (ctx: MyContext) => {
  const chatId = ctx.chat?.id;
  if (!chatId) return;

  const photos = ctx.message.photo;
  if (!photos || photos.length === 0) return;

  // Get largest photo (last in array)
  const largest = photos[photos.length - 1];

  log.info(
    {
      chatId,
      fileId: largest.file_id,
      width: largest.width,
      height: largest.height,
    },
    "Received photo message",
  );

  // Download photo to temp location
  const tempPath = path.join(os.tmpdir(), `klausbot-photo-${Date.now()}.jpg`);

  try {
    const file = await ctx.api.getFile(largest.file_id);
    await file.download(tempPath);

    const media: MediaAttachment[] = [
      {
        type: "photo",
        fileId: largest.file_id,
        localPath: tempPath,
      },
    ];

    // Get caption if any
    const text = ctx.message.caption ?? "";

    const queueId = queue.add(chatId, text, media);
    log.info(
      { chatId, queueId, mediaCount: 1, hasCaption: !!text },
      "Photo message queued",
    );

    processQueue().catch((err) => {
      log.error({ err }, "Queue processing error");
    });
  } catch (err) {
    const msg = err instanceof Error ? err.message : String(err);
    log.error({ err, chatId }, "Failed to download photo");
    await ctx.reply(`Failed to process photo: ${msg}`);
  }
});

// Media group handler (multiple photos in one message)
// Note: grammY fires message:photo for each photo in a media group
// We handle them individually - they'll be queued separately
// Future enhancement: collect media groups using message.media_group_id

// Catch-all for unsupported message types
bot.on("message", async (ctx: MyContext) => {
  const chatId = ctx.chat?.id;
  if (!chatId) return;

  const messageType = Object.keys(ctx.message ?? {}).find(
    (key) =>
      ![
        "message_id",
        "from",
        "chat",
        "date",
        "text",
        "voice",
        "photo",
        "caption",
        "entities",
      ].includes(key),
  );

  log.info({ chatId, messageType }, "Received unsupported message type");

  await ctx.reply(
    "I can process text, voice messages, and photos. Other message types are not yet supported.",
  );
});
```

Also add the MediaAttachment type import at the top if not already there:

```typescript
import type { MediaAttachment } from "../media/index.js";
```

  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `grep "message:voice" src/daemon/gateway.ts` shows voice handler
3. `grep "message:photo" src/daemon/gateway.ts` shows photo handler
4. `grep "isTranscriptionAvailable" src/daemon/gateway.ts` shows capability check
  </verify>
  <done>
- Voice messages downloaded and queued with media attachment
- Photo messages downloaded and queued with media attachment
- Media capabilities logged at startup
- Unsupported types get helpful error message
  </done>
</task>

<task type="auto">
  <name>Task 3: Export MediaAttachment type from daemon index</name>
  <files>src/daemon/index.ts</files>
  <action>
Read current `src/daemon/index.ts`.

Add re-export for MediaAttachment type so it's accessible from daemon module:

```typescript
export type { MediaAttachment } from "../media/index.js";
```

This allows consumers to import types from the daemon module without knowing internal structure.
</action>
<verify>

1. `npx tsc --noEmit` passes
2. `grep "MediaAttachment" src/daemon/index.ts` shows export
   </verify>
   <done>

- MediaAttachment type exported from daemon module
  </done>
  </task>

</tasks>

<verification>
```bash
# All files compile
npx tsc --noEmit

# Bot has hydrateFiles

grep "hydrateFiles" src/telegram/bot.ts

# Gateway has media handlers

grep -E "message:voice|message:photo" src/daemon/gateway.ts

# Capability logging present

grep "Media capabilities" src/daemon/gateway.ts

```
</verification>

<success_criteria>
- hydrateFiles plugin applied in bot.ts
- Voice messages downloaded to temp, queued with MediaAttachment
- Photo messages downloaded to temp, queued with MediaAttachment
- Media capabilities logged at gateway startup
- Unsupported message types get clear error
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-multimodal/06-04-SUMMARY.md`
</output>
```
