# Phase 4.1: Skills Polish - Research

**Researched:** 2026-01-30
**Domain:** CLI interactive prompts, skill registry metadata, system prompt injection
**Confidence:** HIGH

## Summary

Phase 4.1 addresses two skill system gaps:

1. System prompt reminder about skill folder location (`~/.claude/skills/`)
2. CLI `klausbot skills browse` for registry browsing/installation

The codebase already uses `@inquirer/prompts@7.10.1` with `search` prompt available. Anthropic's skills repository provides 16 official skills with standardized SKILL.md format (name + description frontmatter only, no version field). Version tracking must be external (git commit SHA or file hash).

**Primary recommendation:** Use `@inquirer/search` for type-to-filter browsing; hardcode registry with git SHA for version detection; prepend skill folder reminder to system prompt via `buildSystemPrompt()`.

## Standard Stack

### Core

| Library           | Version   | Purpose                 | Why Standard                              |
| ----------------- | --------- | ----------------------- | ----------------------------------------- |
| @inquirer/prompts | 7.10.1    | Interactive CLI prompts | Already installed, includes `search`      |
| @inquirer/search  | (bundled) | Type-to-filter list     | Native support for arrow keys + filtering |

### Supporting

| Library          | Version | Purpose                 | When to Use                  |
| ---------------- | ------- | ----------------------- | ---------------------------- |
| semver           | 7.x     | Version comparison      | If tracking version strings  |
| compare-versions | 6.x     | Lightweight alternative | Simpler API, no dependencies |

**Note:** Version tracking requires external metadata since SKILL.md has no version field.

### Alternatives Considered

| Instead of         | Could Use        | Tradeoff                                     |
| ------------------ | ---------------- | -------------------------------------------- |
| @inquirer/search   | @inquirer/select | Select lacks type-to-filter                  |
| Hardcoded registry | Remote manifest  | Remote adds network dependency, complexity   |
| Git SHA versioning | npm-style semver | Semver cleaner but skills lack version field |

**Installation:**

```bash
# Already installed
npm ls @inquirer/prompts
# 7.10.1 available
```

## Architecture Patterns

### Existing File Structure

```
src/
├── cli/
│   ├── index.ts       # Exports runSkillsCLI
│   ├── skills.ts      # Current implementation
│   └── install.ts     # Reference for CLI patterns
├── daemon/
│   └── spawner.ts     # Uses buildSystemPrompt()
└── memory/
    └── context.ts     # Owns buildSystemPrompt()
```

### Pattern 1: System Prompt Injection Point

**What:** Prepend skill reminder to system prompt
**When to use:** Every Claude session
**Location:** `src/memory/context.ts` - `buildSystemPrompt()`
**Example:**

```typescript
// Source: Codebase analysis
export function buildSystemPrompt(): string {
  const skillReminder = getSkillReminder(); // NEW
  const identity = loadIdentity();
  const instructions = getRetrievalInstructions();

  return skillReminder + "\n\n" + identity + "\n\n" + instructions;
}

function getSkillReminder(): string {
  return `<skill-folder>
When creating or saving skills, use the global skills folder: ~/.claude/skills/
</skill-folder>`;
}
```

### Pattern 2: Search Prompt for Browse

**What:** Interactive type-to-filter skill selection
**When to use:** `klausbot skills browse`
**Example:**

```typescript
// Source: @inquirer/search docs
import { search, confirm } from "@inquirer/prompts";

const selected = await search({
  message: "Search skills:",
  source: (term) => {
    const filtered = REGISTRY.filter(
      (s) => !term || s.name.includes(term) || s.description.includes(term),
    );
    return filtered.map((s) => ({
      name: formatSkillChoice(s), // "skill-name - description [checkmark]"
      value: s.name,
      description: s.description,
    }));
  },
});
```

### Pattern 3: Hardcoded Registry with Metadata

**What:** Static registry array with version tracking
**When to use:** Registry source
**Example:**

```typescript
// Source: Design decision from CONTEXT.md
interface RegistrySkill {
  name: string;
  description: string;
  commands: string[]; // Slash commands it provides
  sha: string; // Git commit SHA for version detection
}

const REGISTRY: RegistrySkill[] = [
  {
    name: "skill-creator",
    description: "Create new skills interactively (Anthropic official)",
    commands: ["/skill-creator"],
    sha: "abc123...", // From anthropics/skills repo
  },
  // ... more skills
];
```

### Anti-Patterns to Avoid

- **Fetching registry on every browse:** Network latency, failure modes. Use hardcoded list.
- **Polling for updates:** Complexity. Check only when browsing.
- **Storing version in SKILL.md:** Not supported by Anthropic spec.

## Don't Hand-Roll

| Problem                      | Don't Build       | Use Instead                | Why                                 |
| ---------------------------- | ----------------- | -------------------------- | ----------------------------------- |
| Interactive list with filter | Custom readline   | @inquirer/search           | Edge cases (cursor, resize, escape) |
| Version comparison           | String comparison | semver or compare-versions | Pre-release handling, edge cases    |
| CLI spinners                 | console.log loops | ora (if needed)            | Terminal control sequences          |

**Key insight:** @inquirer/search handles all UX complexity (arrow navigation, type filtering, terminal resize, ctrl+c) — reimplementing would take 10x longer.

## Common Pitfalls

### Pitfall 1: Source Function Returns on Empty Term

**What goes wrong:** Type-to-filter shows nothing initially
**Why it happens:** Source returns `[]` when term is undefined
**How to avoid:** Return full list when `!term`:

```typescript
source: (term) => {
  if (!term) return REGISTRY.map(...);  // Show all
  return REGISTRY.filter(...);
}
```

**Warning signs:** Browse shows empty list until user types

### Pitfall 2: Version Detection Without Version Field

**What goes wrong:** No way to detect updates
**Why it happens:** SKILL.md spec only has name + description
**How to avoid:** Use git SHA or file content hash:

```typescript
// Compare installed SKILL.md hash vs registry hash
const installed = hashFile(join(SKILLS_DIR, name, "SKILL.md"));
const registry = REGISTRY.find((s) => s.name === name)?.sha;
const hasUpdate = installed !== registry;
```

**Warning signs:** "Update available" indicator never appears

### Pitfall 3: Blocking I/O in System Prompt

**What goes wrong:** Gateway latency spike
**Why it happens:** Reading skill folder on every prompt
**How to avoid:** Cache or keep static (decision: static reminder only):

```typescript
// Static string, no I/O
const SKILL_REMINDER = `<skill-folder>...`;
```

**Warning signs:** Cold start latency increase

### Pitfall 4: Telegram Command Name Mismatch

**What goes wrong:** User taps /skill_creator but Claude sees /skill-creator
**Why it happens:** Already solved in Phase 4 (skillCommandMap translation)
**How to avoid:** Ensure new skills go through existing translation layer
**Warning signs:** Skill commands don't trigger

## Code Examples

### System Prompt Skill Reminder

```typescript
// Source: Design decision - minimal, location only
function getSkillReminder(): string {
  return `<skill-folder>
Skills live in ~/.claude/skills/ — create and save skills there.
</skill-folder>`;
}
```

### Browse with Install Confirmation

```typescript
// Source: @inquirer/prompts docs + design decision
import { search, confirm } from "@inquirer/prompts";

async function browseSkills(): Promise<void> {
  const installed = getInstalledSkills();

  const selected = await search({
    message: "Browse skills (type to filter):",
    source: (term) => {
      const skills = REGISTRY.filter(
        (s) =>
          !term ||
          s.name.toLowerCase().includes(term.toLowerCase()) ||
          s.description.toLowerCase().includes(term.toLowerCase()),
      );
      return skills.map((s) => ({
        name: formatChoice(s, installed),
        value: s.name,
        description: s.description,
      }));
    },
  });

  if (!selected) return;

  const skill = REGISTRY.find((s) => s.name === selected)!;
  const isInstalled = installed.includes(selected);

  // Show confirmation with details
  console.log(`\n${skill.name}`);
  console.log(`  ${skill.description}`);
  console.log(`  Commands: ${skill.commands.join(", ")}`);

  if (isInstalled) {
    const hasUpdate = checkForUpdate(selected);
    if (hasUpdate) {
      const update = await confirm({
        message: "Update available. Install update?",
      });
      if (update) await installSkill(selected);
    } else {
      console.log("  (already installed, up to date)");
    }
  } else {
    const install = await confirm({ message: "Install?" });
    if (install) await installSkill(selected);
  }
}

function formatChoice(skill: RegistrySkill, installed: string[]): string {
  const isInstalled = installed.includes(skill.name);
  const hasUpdate = isInstalled && checkForUpdate(skill.name);

  let badge = "";
  if (isInstalled && hasUpdate) badge = " [up arrow]";
  else if (isInstalled) badge = " [checkmark]";

  return `${skill.name} - ${skill.description}${badge}`;
}
```

### Version Detection via Content Hash

```typescript
// Source: Design pattern for versionless content
import { createHash } from "crypto";
import { readFileSync, existsSync } from "fs";
import { join } from "path";

function getInstalledHash(skillName: string): string | null {
  const path = join(SKILLS_DIR, skillName, "SKILL.md");
  if (!existsSync(path)) return null;
  const content = readFileSync(path, "utf-8");
  return createHash("sha256").update(content).digest("hex").slice(0, 12);
}

function checkForUpdate(skillName: string): boolean {
  const installed = getInstalledHash(skillName);
  const registry = REGISTRY.find((s) => s.name === skillName);
  if (!installed || !registry) return false;
  return installed !== registry.contentHash;
}
```

## State of the Art

| Old Approach           | Current Approach            | When Changed     | Impact                         |
| ---------------------- | --------------------------- | ---------------- | ------------------------------ |
| inquirer (legacy)      | @inquirer/prompts (modular) | v9+              | ESM-native, tree-shakeable     |
| select + manual filter | search prompt               | @inquirer/search | Built-in type-to-filter        |
| Version in frontmatter | External versioning         | Anthropic spec   | Content hash or git SHA needed |

**Deprecated/outdated:**

- `inquirer` legacy package: Use `@inquirer/prompts` instead
- `inquirer-autocomplete-prompt`: Use native `@inquirer/search`

## Open Questions

1. **Registry Update Frequency**
   - What we know: Hardcoded list, updated via klausbot releases
   - What's unclear: How often to update? Manual curation burden
   - Recommendation: Update registry with klausbot versions; monthly review

2. **Content Hash vs Git SHA**
   - What we know: Both work for version detection
   - What's unclear: Git SHA requires API call to get current; content hash requires full download
   - Recommendation: Use content hash of SKILL.md (already fetched during install)

3. **Which Official Skills to Include**
   - What we know: 16 skills in anthropics/skills repo
   - What's unclear: Which are stable/recommended for general use?
   - Recommendation: Start with skill-creator only (already mandatory); expand after curation

## Sources

### Primary (HIGH confidence)

- Codebase: `src/cli/skills.ts`, `src/memory/context.ts`, `src/daemon/spawner.ts`
- @inquirer/prompts npm package — search, select, confirm APIs
- anthropics/skills GitHub repo — SKILL.md spec, available skills

### Secondary (MEDIUM confidence)

- @inquirer/search GitHub docs — source function signature, theme options
- npm semver, compare-versions — version comparison APIs

### Tertiary (LOW confidence)

- None — all findings verified with primary sources

## Metadata

**Confidence breakdown:**

- Standard stack: HIGH — already installed @inquirer/prompts with search
- Architecture: HIGH — clear injection point in buildSystemPrompt()
- Pitfalls: MEDIUM — version detection pattern untested

**Research date:** 2026-01-30
**Valid until:** 2026-03-01 (60 days — stable domain)
