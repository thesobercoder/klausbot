---
phase: 14-testing-framework
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - tests/unit/cron/parse.test.ts
  - tests/unit/cron/schedule.test.ts
  - tests/unit/utils/split.test.ts
  - tests/unit/utils/telegram-html.test.ts
  - tests/unit/config/schema.test.ts
autonomous: true

must_haves:
  truths:
    - "parseSchedule correctly handles intervals, daily, weekday, cron, and natural language"
    - "computeNextRunAtMs returns correct timestamps for at/every/cron schedule kinds"
    - "splitMessage breaks text at sentence/word boundaries respecting 4096 limit"
    - "markdownToTelegramHtml converts bold, italic, code blocks, lists, tables to Telegram HTML"
    - "envSchema rejects missing TELEGRAM_BOT_TOKEN and enforces container OAuth requirement"
    - "jsonConfigSchema applies defaults and rejects unknown keys"
  artifacts:
    - path: "tests/unit/cron/parse.test.ts"
      provides: "parseSchedule unit tests"
      min_lines: 40
    - path: "tests/unit/cron/schedule.test.ts"
      provides: "computeNextRunAtMs unit tests"
      min_lines: 30
    - path: "tests/unit/utils/split.test.ts"
      provides: "splitMessage unit tests"
      min_lines: 25
    - path: "tests/unit/utils/telegram-html.test.ts"
      provides: "markdownToTelegramHtml + escapeHtml + splitTelegramMessage + containsMarkdown tests"
      min_lines: 50
    - path: "tests/unit/config/schema.test.ts"
      provides: "envSchema + jsonConfigSchema validation tests"
      min_lines: 40
  key_links:
    - from: "tests/unit/cron/parse.test.ts"
      to: "src/cron/parse.ts"
      via: "direct import"
      pattern: "import.*parseSchedule"
    - from: "tests/unit/utils/telegram-html.test.ts"
      to: "src/utils/telegram-html.ts"
      via: "direct import"
      pattern: "import.*markdownToTelegramHtml"
---

<objective>
Unit tests for all pure-logic P0 modules: cron parsing, schedule computation, text splitting, markdown-to-HTML conversion, and config schema validation.

Purpose: These modules have zero external dependencies and yield highest coverage per effort. They exercise the core logic that makes klausbot reliable.
Output: 5 test files covering pure functions with comprehensive edge cases.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-testing-framework/14-RESEARCH.md
@src/cron/parse.ts
@src/cron/schedule.ts
@src/cron/types.ts
@src/utils/split.ts
@src/utils/telegram-html.ts
@src/config/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unit tests for cron parsing and schedule computation</name>
  <files>tests/unit/cron/parse.test.ts, tests/unit/cron/schedule.test.ts</files>
  <action>
1. Create `tests/unit/cron/parse.test.ts` testing `parseSchedule` from `../../../src/cron/parse.js`:

**Interval patterns:**

- `"every 5 minutes"` -> kind: "every", everyMs: 300000, humanReadable contains "5 minutes"
- `"every 1 hour"` -> kind: "every", everyMs: 3600000, humanReadable "1 hour" (no plural)
- `"every 2 days"` -> kind: "every", everyMs: 172800000
- `"every 1 second"` -> kind: "every", everyMs: 1000

**Daily patterns:**

- `"every day at 9am"` -> kind: "cron", expr: "0 9 \* \* \*"
- `"daily at 2:30pm"` -> kind: "cron", expr: "30 14 \* \* \*"
- `"every day at 12am"` -> kind: "cron", hour converts to 0 (midnight edge case)
- `"every day at 12pm"` -> kind: "cron", hour stays 12 (noon edge case)

**Weekday patterns:**

- `"every weekday at 8am"` -> kind: "cron", expr: "0 8 \* \* 1-5"
- `"every weekday at 5:30pm"` -> kind: "cron", expr: "30 17 \* \* 1-5"

**Raw cron expressions:**

- `"30 8 * * 1-5"` -> kind: "cron", expr: "30 8 \* \* 1-5"
- `"0 0 * * 0"` -> kind: "cron" (weekly Sunday midnight)
- `"*/5 * * * *"` -> kind: "cron"

**Null cases:**

- `"gobbledygook"` -> null
- `""` -> null
- `"every 0 minutes"` -> null (count must be > 0)

**nextRun:** For interval/cron results, assert nextRun is not null and is a Date in the future.

2. Create `tests/unit/cron/schedule.test.ts` testing `computeNextRunAtMs` from `../../../src/cron/schedule.js`:

   **"at" kind:**
   - Past one-shot (atMs < nowMs) -> null
   - Future one-shot (atMs > nowMs) -> returns atMs
   - atMs exactly at nowMs -> null (not strictly greater)

   **"every" kind:**
   - nowMs before anchor -> returns anchor
   - nowMs exactly at anchor -> returns anchor + everyMs
   - nowMs just past first tick -> returns anchor + 2\*everyMs
   - Large elapsed time (many intervals) -> correct next tick
   - everyMs of 0 or undefined -> handled gracefully (Math.max(1, ...))

   **"cron" kind:**
   - Valid expr "0 9 \* \* \*" -> returns a future timestamp
   - Invalid expr "not a cron" -> null
   - Missing expr (undefined) -> null
   - With timezone option -> does not throw

   **Default kind:**
   - Unknown kind -> null

   Use explicit `nowMs` values (not Date.now()) for deterministic tests.
   </action>
   <verify>`npx vitest run tests/unit/cron/ --reporter=verbose` — all tests pass, no warnings</verify>
   <done>Cron parse and schedule modules have comprehensive test coverage including edge cases and null/error paths.</done>
   </task>

<task type="auto">
  <name>Task 2: Unit tests for text splitting, Telegram HTML, and config schemas</name>
  <files>tests/unit/utils/split.test.ts, tests/unit/utils/telegram-html.test.ts, tests/unit/config/schema.test.ts</files>
  <action>
1. Create `tests/unit/utils/split.test.ts` testing `splitMessage` from `../../../src/utils/split.js`:

- Short text (< 4096) -> returns single-element array
- Text exactly 4096 chars -> single element
- Text 8000 chars with ". " at good boundary -> splits at sentence
- Text 8000 chars with no ". " but has " " -> splits at word boundary
- Text 8000 chars with no spaces -> hard splits at 4095
- Three chunks needed (text ~12000 chars) -> returns 3 elements
- Empty string -> returns [""]
- All chunks are non-empty after split

2. Create `tests/unit/utils/telegram-html.test.ts` testing exports from `../../../src/utils/telegram-html.js`:

   **escapeHtml:**
   - `"<script>"` -> `"&lt;script&gt;"`
   - `"a & b"` -> `"a &amp; b"`
   - `"no special chars"` -> unchanged

   **markdownToTelegramHtml:**
   - `"**bold**"` -> contains `"<b>bold</b>"`
   - `"*italic*"` -> contains `"<i>italic</i>"`
   - ``"`inline code`"`` -> contains `"<code>inline code</code>"`
   - Fenced code block with language -> contains `<pre><code class="language-js">`
   - `"[link](https://example.com)"` -> contains `<a href="https://example.com">link</a>`
   - Bullet list `"- item1\n- item2"` -> contains "item1" and "item2" with bullet chars
   - Ordered list -> contains "1." and "2."
   - Markdown table -> rendered inside `<pre>` tag
   - Heading `"# Title"` -> `<b>Title</b>`
   - Blockquote `"> quote"` -> contains `<blockquote>`
   - `"---"` (hr) -> contains separator

   **containsMarkdown:**
   - Code blocks, inline code, bold, italic, links, headings, blockquotes, tables -> true
   - Plain text with no markdown -> false

   **splitTelegramMessage:**
   - Short text -> single chunk
   - Long text with paragraph break -> splits at `\n\n`
   - Long text no paragraph but sentence -> splits at `. `
   - Custom maxLength parameter respected

3. Create `tests/unit/config/schema.test.ts` testing `envSchema` and `jsonConfigSchema` from `../../../src/config/schema.js`:

   **envSchema:**
   - Valid: `{ TELEGRAM_BOT_TOKEN: "123:ABC" }` -> success, defaults LOG_LEVEL to "info"
   - Missing token: `{}` -> parse fails with error about TELEGRAM_BOT_TOKEN
   - Container mode without OAuth: `{ TELEGRAM_BOT_TOKEN: "x", KLAUSBOT_CONTAINER: "1" }` -> refinement error
   - Container mode with OAuth: `{ TELEGRAM_BOT_TOKEN: "x", KLAUSBOT_CONTAINER: "1", CLAUDE_CODE_OAUTH_TOKEN: "tok" }` -> success
   - Invalid LOG_LEVEL: `{ TELEGRAM_BOT_TOKEN: "x", LOG_LEVEL: "invalid" }` -> fails

   **jsonConfigSchema:**
   - Empty object `{}` -> success with all defaults (model: "claude-opus-4-6", streaming.enabled: true, etc.)
   - Partial override: `{ model: "haiku" }` -> model is "haiku", rest are defaults
   - Unknown key: `{ model: "haiku", unknownField: true }` -> fails (strict mode)
   - Streaming throttle out of range: `{ streaming: { throttleMs: 50 } }` -> fails (min 100)
   - Heartbeat interval too low: `{ heartbeat: { intervalMs: 1000 } }` -> fails (min 60000)
   - Full valid config with all fields -> success

   Use `safeParse` (Zod 4) to test errors without throwing. Check `success` field and error messages.
   </action>
   <verify>`npx vitest run tests/unit/utils/ tests/unit/config/ --reporter=verbose` — all tests pass</verify>
   <done>Pure-logic modules fully covered: text splitting, Telegram HTML conversion, and config schema validation all have tests with edge cases.</done>
   </task>

</tasks>

<verification>
- `npm test` passes all unit tests
- `npm run test:coverage` shows >40% statement coverage on tested modules
- No mocks needed — all tests exercise real source code directly
</verification>

<success_criteria>

1. cron/parse.ts: interval, daily, weekday, raw cron, natural language, and null cases tested
2. cron/schedule.ts: at/every/cron kinds tested with deterministic time values
3. utils/split.ts: sentence, word, hard split boundaries tested
4. utils/telegram-html.ts: all conversion functions tested (bold, italic, code, lists, tables, links)
5. config/schema.ts: both env and JSON schemas tested for valid, invalid, and edge cases
6. All tests pass on `npm test`
   </success_criteria>

<output>
After completion, create `.planning/phases/14-testing-framework/14-02-SUMMARY.md`
</output>
