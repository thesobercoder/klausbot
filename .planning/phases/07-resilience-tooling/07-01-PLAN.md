---
phase: 07-resilience-tooling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/daemon/transcript.ts
  - src/daemon/spawner.ts
  - src/daemon/index.ts
autonomous: true

must_haves:
  truths:
    - "When Claude times out, spawner attempts to recover response from transcript"
    - "Transcript path constructed from cwd: /home/user/klausbot -> -home-user-klausbot"
    - "Most recent chat_*.jsonl file selected by modification time"
    - "Last assistant response extracted from JSONL entries"
  artifacts:
    - path: "src/daemon/transcript.ts"
      provides: "Transcript path construction and JSONL parsing"
      exports:
        [
          "getTranscriptDir",
          "findLatestTranscript",
          "extractLastAssistantResponse",
        ]
    - path: "src/daemon/spawner.ts"
      provides: "Timeout recovery integration"
      contains: "handleTimeout"
  key_links:
    - from: "src/daemon/spawner.ts"
      to: "src/daemon/transcript.ts"
      via: "import { handleTimeout }"
      pattern: "import.*transcript"
---

<objective>
Implement timeout recovery by parsing Claude CLI transcripts to recover partial responses.

Purpose: When Claude times out after 5 minutes, user loses all work. Transcript recovery salvages the last assistant response from ~/.claude/projects/ JSONL files.

Output: New transcript.ts module + spawner integration that attempts recovery on timeout.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-resilience-tooling/07-RESEARCH.md
@src/daemon/spawner.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create transcript.ts module</name>
  <files>src/daemon/transcript.ts</files>
  <action>
Create new module with three functions:

1. `getTranscriptDir(cwd: string): string`
   - Convert cwd to Claude's transcript directory path
   - /home/user/klausbot -> -home-user-klausbot
   - Return: `path.join(os.homedir(), '.claude', 'projects', '-' + sanitized)`
   - Sanitize: strip leading slash, replace all / with -

2. `findLatestTranscript(projectDir: string): string | null`
   - Check if projectDir exists, return null if not
   - List files matching `chat_*.jsonl`
   - Sort by mtime descending
   - Return path to most recent, or null if none

3. `extractLastAssistantResponse(transcriptPath: string): string | null`
   - Read file line by line
   - Parse each non-empty line as JSON
   - Track last entry where type === 'assistant'
   - Extract text from message.content[0].text
   - Return last assistant text found, or null

Define interface:

```typescript
interface TranscriptEntry {
  type: "user" | "assistant" | "summary" | "system";
  message?: {
    content?: Array<{ type: string; text: string }>;
  };
  timestamp?: string;
}
```

Export `handleTimeout(cwd: string): string | null` that chains all three:

- getTranscriptDir -> findLatestTranscript -> extractLastAssistantResponse
- If successful, return `[Recovered from timeout]\n\n${response}`
- Return null on any failure (no transcript, no response)

Use Node.js fs (readFileSync, existsSync, readdirSync, statSync), path, os builtins only.
</action>
<verify>TypeScript compiles: `npm run build`</verify>
<done>transcript.ts exports getTranscriptDir, findLatestTranscript, extractLastAssistantResponse, handleTimeout</done>
</task>

<task type="auto">
  <name>Task 2: Integrate timeout recovery in spawner</name>
  <files>src/daemon/spawner.ts, src/daemon/index.ts</files>
  <action>
In spawner.ts:

1. Import handleTimeout from transcript.ts

2. In the timeout handler (line ~162-167 where timedOut is true):
   - Before rejecting, attempt recovery:

   ```typescript
   if (timedOut) {
     const recovered = handleTimeout(KLAUSBOT_HOME);
     if (recovered) {
       logger.info({ duration_ms }, "Recovered response from timeout");
       resolve({
         result: recovered,
         cost_usd: 0, // Unknown cost for recovered response
         session_id: "recovered",
         duration_ms,
         is_error: false,
       });
       return;
     }
     // Original timeout error if recovery fails
     const timeoutSec = Math.round(timeout / 1000);
     const error = `Claude timed out after ${timeoutSec} seconds`;
     logger.error({ timeout, duration_ms }, error);
     reject(new Error(error));
     return;
   }
   ```

3. Log recovery attempts at info level

In index.ts (daemon barrel):

- Add export for handleTimeout if useful elsewhere (optional)

Keep existing timeout flow as fallback when recovery fails.
</action>
<verify>`npm run build` compiles without errors</verify>
<done>Timeout handler attempts transcript recovery before returning error</done>
</task>

</tasks>

<verification>
- [ ] `npm run build` succeeds
- [ ] transcript.ts creates correct path: `/home/user/foo` -> `~/.claude/projects/-home-user-foo`
- [ ] Empty/missing transcript dir returns null gracefully
- [ ] Spawner attempts recovery on timeout
</verification>

<success_criteria>

- Transcript path construction follows Claude CLI format
- Most recent transcript file selected
- Last assistant response extracted from JSONL
- Timeout handler returns recovered response when available
- Graceful fallback to error when recovery unavailable
  </success_criteria>

<output>
After completion, create `.planning/phases/07-resilience-tooling/07-01-SUMMARY.md`
</output>
