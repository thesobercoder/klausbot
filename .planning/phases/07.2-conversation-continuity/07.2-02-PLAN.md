---
phase: 07.2-conversation-continuity
plan: 02
type: execute
wave: 2
depends_on: ["07.2-01"]
files_modified:
  - src/memory/schema.ts
  - src/memory/db.ts
  - src/memory/conversations.ts
  - src/cli/hook.ts
  - src/daemon/gateway.ts
  - package.json
  - drizzle.config.ts
autonomous: true

must_haves:
  truths:
    - "conversations table stores session_id, transcript, summary, timestamps"
    - "SessionEnd hook parses transcript and stores conversation"
    - "Summaries generated via OpenAI API"
    - "Drizzle migrations run on gateway startup"
    - "Recent conversation summaries appear in SessionStart context output"
  artifacts:
    - path: "src/memory/schema.ts"
      provides: "Drizzle schema with conversations table"
      exports: ["conversations", "embeddings"]
    - path: "src/memory/conversations.ts"
      provides: "Conversation CRUD operations"
      exports: ["storeConversation", "getRecentConversations"]
    - path: "drizzle.config.ts"
      provides: "Drizzle configuration for SQLite"
  key_links:
    - from: "src/cli/hook.ts"
      to: "src/memory/conversations.ts"
      via: "import and call storeConversation"
      pattern: "storeConversation"
    - from: "src/daemon/gateway.ts"
      to: "src/memory/db.ts"
      via: "runMigrations on startup"
      pattern: "runMigrations"
---

<objective>
Implement conversation storage with Drizzle ORM and complete hook handlers.

Purpose: Store conversations in SQLite with summaries for future search
Output: conversations table, Drizzle schema, working SessionEnd hook
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.2-conversation-continuity/07.2-RESEARCH.md
@.planning/phases/07.2-conversation-continuity/07.2-01-SUMMARY.md

Key decisions from RESEARCH.md:

- Use drizzle-kit push for simple schemas (no migration files needed)
- better-sqlite3 is sync (important for SessionEnd - can't be async)
- Summary via OpenAI API (already configured for embeddings)
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Install Drizzle and create schema</name>
  <files>package.json, src/memory/schema.ts, drizzle.config.ts</files>
  <action>
1. Install Drizzle:
```bash
npm install drizzle-orm
npm install --save-dev drizzle-kit
```

2. Create src/memory/schema.ts:

```typescript
/**
 * Drizzle ORM schema for klausbot SQLite database
 */

import { sqliteTable, text, integer } from "drizzle-orm/sqlite-core";

/**
 * Embeddings table (migrated from raw SQL)
 * Stores text with vector embeddings for semantic search
 */
export const embeddings = sqliteTable("embeddings", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  textId: text("text_id").unique().notNull(),
  text: text("text").notNull(),
  timestamp: text("timestamp").notNull(),
  source: text("source").notNull(),
});

/**
 * Conversations table
 * Stores full transcripts with summaries for history search
 */
export const conversations = sqliteTable("conversations", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  sessionId: text("session_id").unique().notNull(),
  startedAt: text("started_at").notNull(),
  endedAt: text("ended_at").notNull(),
  transcript: text("transcript").notNull(), // Full JSONL content
  summary: text("summary").notNull(), // LLM-generated summary
  messageCount: integer("message_count").notNull(),
  chatId: integer("chat_id"), // Telegram chat ID (nullable)
});

/**
 * Conversation embeddings table
 * Links conversation chunks to vector embeddings for search
 */
export const conversationEmbeddings = sqliteTable("conversation_embeddings", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  conversationId: integer("conversation_id").notNull(),
  chunkIndex: integer("chunk_index").notNull(),
  text: text("text").notNull(),
});
```

3. Create drizzle.config.ts at project root:

```typescript
import { defineConfig } from "drizzle-kit";
import { homedir } from "os";
import { join } from "path";

export default defineConfig({
  dialect: "sqlite",
  schema: "./src/memory/schema.ts",
  out: "./drizzle/migrations",
  dbCredentials: {
    url: "file:" + join(homedir(), ".klausbot", "klausbot.db"),
  },
});
```

  </action>
  <verify>
TypeScript compiles: `npm run build`
Drizzle config valid: `npx drizzle-kit check`
  </verify>
  <done>Drizzle ORM installed, schema defined, config created</done>
</task>

<task type="auto">
  <name>Task 2: Update db.ts for Drizzle and add migration</name>
  <files>src/memory/db.ts</files>
  <action>
Update db.ts to:
1. Export Drizzle instance alongside raw database
2. Add schema push function for runtime migration

Replace existing db.ts content:

```typescript
import Database from "better-sqlite3";
import { drizzle, BetterSQLite3Database } from "drizzle-orm/better-sqlite3";
import * as sqliteVec from "sqlite-vec";
import { getHomePath } from "./home.js";
import * as schema from "./schema.js";

/** Lazy-initialized database instances */
let sqliteDb: Database.Database | null = null;
let drizzleDb: BetterSQLite3Database<typeof schema> | null = null;

/**
 * Get or create SQLite database with vector extension
 * Lazy initialization - creates DB on first call
 *
 * @returns Raw better-sqlite3 database instance
 */
export function getDb(): Database.Database {
  if (sqliteDb !== null) {
    return sqliteDb;
  }

  const dbPath = getHomePath("klausbot.db");
  sqliteDb = new Database(dbPath);

  // Enable WAL mode for concurrent reads
  sqliteDb.pragma("journal_mode = WAL");

  // Load sqlite-vec extension
  sqliteVec.load(sqliteDb);

  // Create legacy schema (vec table needs raw SQL)
  sqliteDb.exec(`
    CREATE TABLE IF NOT EXISTS embeddings (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      text_id TEXT UNIQUE NOT NULL,
      text TEXT NOT NULL,
      timestamp TEXT NOT NULL,
      source TEXT NOT NULL
    );
    CREATE INDEX IF NOT EXISTS idx_embeddings_timestamp ON embeddings(timestamp);
    CREATE INDEX IF NOT EXISTS idx_embeddings_source ON embeddings(source);

    CREATE VIRTUAL TABLE IF NOT EXISTS vec_embeddings USING vec0(
      embedding float[1536]
    );
  `);

  return sqliteDb;
}

/**
 * Get Drizzle ORM instance
 * Creates raw DB first if needed
 *
 * @returns Drizzle database instance with schema
 */
export function getDrizzle(): BetterSQLite3Database<typeof schema> {
  if (drizzleDb !== null) {
    return drizzleDb;
  }

  // Ensure raw DB is initialized first (creates tables)
  const db = getDb();
  drizzleDb = drizzle(db, { schema });

  return drizzleDb;
}

/**
 * Run schema migrations
 * Creates conversations table if not exists
 * Safe to call multiple times (idempotent)
 */
export function runMigrations(): void {
  const db = getDb();

  // Create conversations table (Drizzle schema equivalent)
  db.exec(`
    CREATE TABLE IF NOT EXISTS conversations (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      session_id TEXT UNIQUE NOT NULL,
      started_at TEXT NOT NULL,
      ended_at TEXT NOT NULL,
      transcript TEXT NOT NULL,
      summary TEXT NOT NULL,
      message_count INTEGER NOT NULL,
      chat_id INTEGER
    );
    CREATE INDEX IF NOT EXISTS idx_conversations_ended_at ON conversations(ended_at);
    CREATE INDEX IF NOT EXISTS idx_conversations_chat_id ON conversations(chat_id);

    CREATE TABLE IF NOT EXISTS conversation_embeddings (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      conversation_id INTEGER NOT NULL,
      chunk_index INTEGER NOT NULL,
      text TEXT NOT NULL
    );
    CREATE INDEX IF NOT EXISTS idx_conv_emb_conv_id ON conversation_embeddings(conversation_id);
  `);
}

/**
 * Close database connection
 * Call on shutdown for clean exit
 */
export function closeDb(): void {
  if (sqliteDb !== null) {
    sqliteDb.close();
    sqliteDb = null;
    drizzleDb = null;
  }
}
```

Note: Using raw SQL for migrations instead of drizzle-kit push to avoid runtime complexity.
</action>
<verify>Build succeeds: `npm run build`</verify>
<done>db.ts exports Drizzle instance and runMigrations()</done>
</task>

<task type="auto">
  <name>Task 3: Create conversation storage module</name>
  <files>src/memory/conversations.ts, src/memory/index.ts</files>
  <action>
1. Create src/memory/conversations.ts:

```typescript
/**
 * Conversation storage operations
 * Stores and retrieves conversation transcripts with summaries
 */

import { eq, desc, gte } from "drizzle-orm";
import { getDrizzle } from "./db.js";
import { conversations } from "./schema.js";
import OpenAI from "openai";

const openai = new OpenAI();

/** Conversation record for storage */
export interface ConversationRecord {
  sessionId: string;
  startedAt: string;
  endedAt: string;
  transcript: string;
  summary: string;
  messageCount: number;
  chatId?: number;
}

/** Transcript entry structure (from Claude CLI JSONL) */
interface TranscriptEntry {
  type: "user" | "assistant" | "summary" | "system";
  timestamp?: string;
  message?: {
    role?: string;
    content?: Array<{ type: string; text?: string }>;
  };
}

/**
 * Parse JSONL transcript file content
 */
export function parseTranscript(content: string): TranscriptEntry[] {
  const lines = content.split("\n").filter((line) => line.trim());
  const entries: TranscriptEntry[] = [];

  for (const line of lines) {
    try {
      entries.push(JSON.parse(line) as TranscriptEntry);
    } catch {
      // Skip malformed lines
    }
  }

  return entries;
}

/**
 * Extract text content from transcript entries
 */
export function extractConversationText(entries: TranscriptEntry[]): string {
  const parts: string[] = [];

  for (const entry of entries) {
    if (
      (entry.type === "user" || entry.type === "assistant") &&
      entry.message?.content
    ) {
      const textContent = entry.message.content
        .filter((c) => c.type === "text" && c.text)
        .map((c) => c.text)
        .join("\n");

      if (textContent) {
        const role = entry.type === "user" ? "User" : "Assistant";
        parts.push(`${role}: ${textContent}`);
      }
    }
  }

  return parts.join("\n\n");
}

/**
 * Generate summary of conversation using OpenAI
 */
export async function generateSummary(
  conversationText: string,
): Promise<string> {
  // Skip if conversation is very short
  if (conversationText.length < 100) {
    return "Brief conversation.";
  }

  // Truncate very long conversations for summarization
  const maxLength = 10000;
  const truncated =
    conversationText.length > maxLength
      ? conversationText.slice(0, maxLength) + "\n...[truncated]"
      : conversationText;

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content:
            "Summarize this conversation in 2-3 sentences. Focus on the main topics discussed and any conclusions or outcomes.",
        },
        {
          role: "user",
          content: truncated,
        },
      ],
      max_tokens: 200,
      temperature: 0.3,
    });

    return (
      response.choices[0]?.message?.content ??
      "Conversation summary unavailable."
    );
  } catch (err) {
    // Fallback if API fails
    const preview = conversationText.slice(0, 200).replace(/\n/g, " ");
    return `Conversation about: ${preview}...`;
  }
}

/**
 * Store a conversation record
 */
export function storeConversation(record: ConversationRecord): void {
  const db = getDrizzle();

  db.insert(conversations)
    .values({
      sessionId: record.sessionId,
      startedAt: record.startedAt,
      endedAt: record.endedAt,
      transcript: record.transcript,
      summary: record.summary,
      messageCount: record.messageCount,
      chatId: record.chatId ?? null,
    })
    .onConflictDoUpdate({
      target: conversations.sessionId,
      set: {
        endedAt: record.endedAt,
        transcript: record.transcript,
        summary: record.summary,
        messageCount: record.messageCount,
      },
    })
    .run();
}

/**
 * Get recent conversation summaries for context injection
 */
export function getRecentConversations(
  limit: number = 3,
  daysBack?: number,
): ConversationRecord[] {
  const db = getDrizzle();

  let query = db
    .select()
    .from(conversations)
    .orderBy(desc(conversations.endedAt))
    .limit(limit);

  if (daysBack) {
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - daysBack);
    query = db
      .select()
      .from(conversations)
      .where(gte(conversations.endedAt, cutoff.toISOString()))
      .orderBy(desc(conversations.endedAt))
      .limit(limit);
  }

  return query.all() as ConversationRecord[];
}

/**
 * Get a conversation by session ID
 */
export function getConversationBySessionId(
  sessionId: string,
): ConversationRecord | null {
  const db = getDrizzle();

  const result = db
    .select()
    .from(conversations)
    .where(eq(conversations.sessionId, sessionId))
    .get();

  return result as ConversationRecord | null;
}
```

2. Add exports to src/memory/index.ts:

```typescript
// Add to existing exports
export { runMigrations, getDrizzle } from "./db.js";
export {
  storeConversation,
  getRecentConversations,
  getConversationBySessionId,
  parseTranscript,
  extractConversationText,
  generateSummary,
  type ConversationRecord,
} from "./conversations.js";
```

  </action>
  <verify>Build succeeds: `npm run build`</verify>
  <done>Conversation storage module with parse/summarize/store operations</done>
</task>

<task type="auto">
  <name>Task 4: Complete hook handlers with storage</name>
  <files>src/cli/hook.ts</files>
  <action>
Update hook.ts to use conversation storage:

```typescript
/**
 * Hook CLI handlers for Claude Code integration
 * Receives JSON from stdin, processes session events
 */

import { stdin } from "process";
import { readFileSync, existsSync } from "fs";

/** Claude Code hook input structure */
interface HookInput {
  session_id: string;
  transcript_path: string;
  cwd: string;
  hook_event_name: string;
  source?: string;
  reason?: string;
}

/**
 * Read JSON from stdin (non-blocking with timeout)
 */
async function readStdin(timeoutMs = 5000): Promise<HookInput> {
  const chunks: Buffer[] = [];

  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error("stdin timeout"));
    }, timeoutMs);

    stdin.on("data", (chunk: Buffer) => {
      chunks.push(chunk);
    });

    stdin.on("end", () => {
      clearTimeout(timeout);
      try {
        const json = Buffer.concat(chunks).toString("utf-8");
        resolve(JSON.parse(json) as HookInput);
      } catch (err) {
        reject(new Error(`Invalid JSON: ${err}`));
      }
    });

    stdin.on("error", (err) => {
      clearTimeout(timeout);
      reject(err);
    });
  });
}

/**
 * Handle SessionStart hook
 * Outputs context to stdout (injected into Claude session)
 */
export async function handleHookStart(): Promise<void> {
  const input = await readStdin();

  // Dynamic import to avoid loading DB on every CLI call
  const { getRecentConversations } = await import("../memory/conversations.js");

  // Get current datetime
  const datetime = new Date().toISOString();

  // Get recent conversation summaries (last 3)
  let summariesText = "";
  try {
    const recent = getRecentConversations(3);
    if (recent.length > 0) {
      summariesText = recent
        .map((c) => {
          const date = new Date(c.endedAt).toLocaleDateString();
          return `- ${date}: ${c.summary}`;
        })
        .join("\n");
    }
  } catch {
    // Ignore errors - may be first run before tables exist
  }

  // Build context block
  const context = `<session-context>
Current datetime: ${datetime}
Session ID: ${input.session_id}
${summariesText ? `\nRecent conversations:\n${summariesText}` : ""}
</session-context>`;

  // Write to stdout - Claude adds this to context
  console.log(context);
}

/**
 * Handle PreCompact hook
 * Saves conversation state before context window compaction
 */
export async function handleHookCompact(): Promise<void> {
  const input = await readStdin();

  // Pre-compact: could save partial transcript here
  // For now, just acknowledge - full save happens in SessionEnd
  console.error(`[hook:compact] session=${input.session_id}`);
}

/**
 * Handle SessionEnd hook
 * Copies transcript to storage, generates summary
 */
export async function handleHookEnd(): Promise<void> {
  const input = await readStdin();

  console.error(
    `[hook:end] session=${input.session_id} path=${input.transcript_path}`,
  );

  // Read transcript file
  if (!existsSync(input.transcript_path)) {
    console.error(`[hook:end] Transcript not found: ${input.transcript_path}`);
    return;
  }

  const transcriptContent = readFileSync(input.transcript_path, "utf-8");

  // Dynamic imports
  const {
    parseTranscript,
    extractConversationText,
    generateSummary,
    storeConversation,
  } = await import("../memory/conversations.js");

  // Parse transcript
  const entries = parseTranscript(transcriptContent);
  const messageCount = entries.filter(
    (e) => e.type === "user" || e.type === "assistant",
  ).length;

  if (messageCount === 0) {
    console.error("[hook:end] No messages in transcript, skipping");
    return;
  }

  // Extract timestamps
  const timestamps = entries
    .filter((e) => e.timestamp)
    .map((e) => e.timestamp!)
    .sort();

  const startedAt = timestamps[0] ?? new Date().toISOString();
  const endedAt = timestamps[timestamps.length - 1] ?? new Date().toISOString();

  // Generate summary
  const conversationText = extractConversationText(entries);
  const summary = await generateSummary(conversationText);

  // Store conversation
  storeConversation({
    sessionId: input.session_id,
    startedAt,
    endedAt,
    transcript: transcriptContent,
    summary,
    messageCount,
    // chatId: extracted from session metadata if available
  });

  console.error(
    `[hook:end] Stored conversation: ${messageCount} messages, summary: ${summary.slice(0, 50)}...`,
  );
}
```

  </action>
  <verify>
Build succeeds: `npm run build`
Test SessionStart outputs context: `echo '{"session_id":"test","transcript_path":"/tmp/test.jsonl","cwd":"/tmp","hook_event_name":"SessionStart"}' | npx tsx src/index.ts hook start`
  </verify>
  <done>Hook handlers complete with conversation storage</done>
</task>

<task type="auto">
  <name>Task 5: Add migrations to gateway startup</name>
  <files>src/daemon/gateway.ts</files>
  <action>
In gateway.ts startGateway():

1. Add import:

```typescript
import { runMigrations } from "../memory/index.js";
```

2. After `initializeHome(log);` line, add:

```typescript
// Run database migrations (creates tables if needed)
runMigrations();
log.info("Database migrations complete");
```

This ensures conversations table exists before any hooks run.
</action>
<verify>
Build succeeds: `npm run build`
Gateway starts: `npx tsx src/index.ts daemon` (verify "Database migrations complete" in logs, Ctrl+C)
</verify>
<done>Gateway runs migrations on startup</done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build`
2. Migrations run: Start gateway, check for "Database migrations complete" log
3. Table exists: `sqlite3 ~/.klausbot/klausbot.db ".tables"` shows `conversations`
4. SessionStart injects datetime: Test with echo pipe
5. SessionEnd stores: Create test JSONL, run hook end, check DB
</verification>

<success_criteria>

- Drizzle ORM configured with schema
- conversations table created on gateway startup
- SessionEnd hook parses transcript and stores with summary
- SessionStart hook outputs recent conversation summaries
- All operations are synchronous-compatible (better-sqlite3)
  </success_criteria>

<output>
After completion, create `.planning/phases/07.2-conversation-continuity/07.2-02-SUMMARY.md`
</output>
