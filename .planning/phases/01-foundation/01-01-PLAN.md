---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - .env.example
  - src/config/schema.ts
  - src/config/loader.ts
  - src/utils/logger.ts
autonomous: true

must_haves:
  truths:
    - "npm install succeeds without errors"
    - "TypeScript compiles without errors"
    - "Config loads from .env file"
    - "Logger outputs structured JSON"
  artifacts:
    - path: "package.json"
      provides: "Project manifest with all dependencies"
      contains: "grammy"
    - path: "tsconfig.json"
      provides: "TypeScript configuration"
      contains: "strict"
    - path: "src/config/schema.ts"
      provides: "Zod schemas for config validation"
      exports: ["configSchema", "Config"]
    - path: "src/config/loader.ts"
      provides: "Config loading from env"
      exports: ["loadConfig", "config"]
    - path: "src/utils/logger.ts"
      provides: "Pino logger setup"
      exports: ["logger", "createChildLogger"]
  key_links:
    - from: "src/config/loader.ts"
      to: "src/config/schema.ts"
      via: "zod parse"
      pattern: "configSchema\\.parse"
---

<objective>
Initialize klausbot TypeScript project with all dependencies, config system, and structured logging.

Purpose: Establish foundation that all other plans build upon - consistent config access and logging.
Output: Working npm project with grammY stack, config loader, and pino logger.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize npm project with dependencies</name>
  <files>package.json, tsconfig.json, .env.example, .gitignore</files>
  <action>
Create package.json with:
- name: "klausbot"
- type: "module" (ESM)
- scripts: "build", "dev", "start"
- dependencies: grammy, @grammyjs/runner, @grammyjs/auto-retry, @grammyjs/auto-chat-action, @inquirer/prompts, pino, zod, dotenv
- devDependencies: typescript, @types/node, tsx

Create tsconfig.json:
- target: ES2022
- module: NodeNext
- moduleResolution: NodeNext
- strict: true
- outDir: dist
- rootDir: src

Create .env.example with:
- TELEGRAM_BOT_TOKEN=your_telegram_bot_token
- LOG_LEVEL=info
- DATA_DIR=./data

Update .gitignore:
- node_modules/, dist/, .env, data/

Run npm install.
  </action>
  <verify>npm install completes without errors; npm run build compiles (may show "no input files" initially)</verify>
  <done>package.json exists with all deps, tsconfig.json valid, npm install succeeded</done>
</task>

<task type="auto">
  <name>Task 2: Create config schema and loader</name>
  <files>src/config/schema.ts, src/config/loader.ts, src/config/index.ts</files>
  <action>
Create src/config/schema.ts:
- Import zod
- Define configSchema with:
  - TELEGRAM_BOT_TOKEN: z.string().min(1)
  - LOG_LEVEL: z.enum(['trace','debug','info','warn','error','fatal']).default('info')
  - DATA_DIR: z.string().default('./data')
- Export Config type (z.infer)

Create src/config/loader.ts:
- Import dotenv/config (side effect import for loading)
- Import configSchema
- Export loadConfig() that parses process.env through schema
- Export singleton config (lazy-loaded on first access)
- Throw descriptive error if validation fails (list missing/invalid fields)

Create src/config/index.ts:
- Re-export everything from schema and loader
  </action>
  <verify>Create test file that imports config; verify it throws if TELEGRAM_BOT_TOKEN missing; verify it loads if .env valid</verify>
  <done>Config loads from .env, validates with zod, exports typed Config object</done>
</task>

<task type="auto">
  <name>Task 3: Create logger utility</name>
  <files>src/utils/logger.ts, src/utils/index.ts</files>
  <action>
Create src/utils/logger.ts:
- Import pino
- Import config (lazy - only access LOG_LEVEL when logger created)
- Create base logger with:
  - level from config.LOG_LEVEL
  - formatters.level that outputs level name (not number)
  - timestamp: pino.stdTimeFunctions.isoTime
- Export logger (singleton)
- Export createChildLogger(name: string) for module-specific loggers

Create src/utils/index.ts:
- Re-export from logger.ts

Ensure circular dependency avoided: logger should not import config at module level, only when logger() is first called.
  </action>
  <verify>Run: node -e "import('./dist/utils/logger.js').then(m => m.logger.info('test'))" outputs JSON with level, time, msg</verify>
  <done>Logger outputs structured JSON, supports child loggers, respects LOG_LEVEL</done>
</task>

</tasks>

<verification>
After all tasks:
1. `npm run build` succeeds with no errors
2. Create .env with TELEGRAM_BOT_TOKEN=test123, run quick test:
   ```
   node -e "
   import { config } from './dist/config/index.js';
   import { logger } from './dist/utils/index.js';
   console.log('Config loaded:', !!config.TELEGRAM_BOT_TOKEN);
   logger.info({ token: config.TELEGRAM_BOT_TOKEN.slice(0,4) + '...' }, 'Test log');
   "
   ```
3. Output shows structured JSON log with masked token
</verification>

<success_criteria>
- npm install and build succeed
- Config validates TELEGRAM_BOT_TOKEN (required), LOG_LEVEL (optional), DATA_DIR (optional)
- Logger outputs JSON with level name, ISO timestamp, message
- No TypeScript errors
- Clean foundation for Plan 02 (Telegram bot)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
