---
phase: 07.1-memory-search-mcp
plan: 02
type: execute
wave: 2
depends_on: ["07.1-01"]
files_modified:
  - src/memory/search.ts
  - src/mcp-server/tools/memory.ts
  - src/mcp-server/index.ts
autonomous: true

must_haves:
  truths:
    - "Claude can search past conversations via MCP tool"
    - "Date-based filtering works (last N days)"
    - "Search returns relevant memories with scores"
  artifacts:
    - path: "src/mcp-server/tools/memory.ts"
      provides: "search_memories MCP tool"
      exports: ["registerMemoryTools"]
    - path: "src/memory/search.ts"
      provides: "SQLite-backed semantic search"
      exports: ["semanticSearch"]
  key_links:
    - from: "src/mcp-server/tools/memory.ts"
      to: "src/memory/search.ts"
      via: "semanticSearch() call"
      pattern: "semanticSearch"
    - from: "src/memory/search.ts"
      to: "src/memory/db.ts"
      via: "getDb() for KNN query"
      pattern: "getDb\\(\\)"
---

<objective>
MCP tool for semantic memory search

Purpose: Expose memory search to Claude via typed MCP tool. Currently embeddings exist but Claude cannot query them.

Output: Updated search.ts with sqlite-vec KNN, search_memories MCP tool
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07.1-memory-search-mcp/07.1-RESEARCH.md
@.planning/phases/07.1-memory-search-mcp/07.1-01-SUMMARY.md

@src/memory/search.ts
@src/memory/db.ts
@src/mcp-server/index.ts
@src/mcp-server/tools/cron.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update search.ts to use sqlite-vec KNN</name>
  <files>
    src/memory/search.ts
  </files>
  <action>
Rewrite `src/memory/search.ts` to use sqlite-vec instead of in-memory cosine similarity:

```typescript
import { getDb } from "./db.js";
import { generateEmbedding } from "./embeddings.js";

export interface SearchResult {
  text: string;
  score: number;
  source: string;
  timestamp: string;
}

interface SearchOptions {
  topK?: number;
  daysBack?: number; // Filter to last N days
}

export async function semanticSearch(
  query: string,
  options: SearchOptions = {},
): Promise<SearchResult[]> {
  const { topK = 5, daysBack } = options;

  // Generate query embedding
  const queryEmbedding = await generateEmbedding(query);
  if (!queryEmbedding) {
    return [];
  }

  const db = getDb();
  const buffer = new Float32Array(queryEmbedding).buffer;

  // Build query with optional date filter
  let sql = `
    SELECT
      e.text,
      e.source,
      e.timestamp,
      v.distance
    FROM vec_embeddings v
    INNER JOIN embeddings e ON e.id = v.rowid
    WHERE v.embedding MATCH ?
  `;

  const params: any[] = [buffer];

  if (daysBack !== undefined && daysBack > 0) {
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - daysBack);
    sql += ` AND e.timestamp >= ?`;
    params.push(cutoff.toISOString());
  }

  sql += ` ORDER BY v.distance LIMIT ?`;
  params.push(topK);

  // Execute KNN search
  const rows = db.prepare(sql).all(...params) as Array<{
    text: string;
    source: string;
    timestamp: string;
    distance: number;
  }>;

  // Convert distance to similarity score (sqlite-vec returns L2 distance)
  // Lower distance = more similar, convert to 0-1 score where 1 = identical
  return rows.map((row) => ({
    text: row.text,
    source: row.source,
    timestamp: row.timestamp,
    score: 1 / (1 + row.distance), // Convert distance to similarity
  }));
}

// Export for direct use (e.g., testing)
export { cosineSimilarity } from "./embeddings.js"; // Keep if needed elsewhere
```

Remove:

- loadStoredEmbeddings() (no longer reads JSON)
- In-memory cosine similarity loop
- MIN_SCORE_THRESHOLD (sqlite-vec handles relevance)

PITFALL AVOIDANCE:

- Float32Array.buffer for query embedding
- vec0 MATCH syntax for KNN search
- Join on rowid to get text data
  </action>
  <verify>
  `npm run build` succeeds
  Create test embedding, run search:

```typescript
const results = await semanticSearch("test query", { topK: 3 });
```

  </verify>
  <done>
semanticSearch uses sqlite-vec KNN, supports daysBack filter
  </done>
</task>

<task type="auto">
  <name>Task 2: Add search_memories MCP tool</name>
  <files>
    src/mcp-server/tools/memory.ts
    src/mcp-server/index.ts
  </files>
  <action>
Create `src/mcp-server/tools/memory.ts`:

```typescript
import { z } from "zod";
import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { semanticSearch } from "../../memory/search.js";

export function registerMemoryTools(server: McpServer): void {
  server.tool(
    "search_memories",
    "Search past conversations semantically. Returns relevant memories based on meaning, not just keywords.",
    {
      query: z
        .string()
        .describe(
          'Natural language search query (e.g., "discussions about project deadlines")',
        ),
      limit: z
        .number()
        .optional()
        .default(5)
        .describe("Max results to return (default: 5)"),
      days_back: z
        .number()
        .optional()
        .describe("Only search memories from last N days (omit for all time)"),
    },
    async ({ query, limit, days_back }) => {
      try {
        const results = await semanticSearch(query, {
          topK: limit,
          daysBack: days_back,
        });

        if (results.length === 0) {
          return {
            content: [
              {
                type: "text" as const,
                text: "No relevant memories found for that query.",
              },
            ],
          };
        }

        // Format results
        const formatted = results
          .map((r, i) => {
            const date = new Date(r.timestamp).toLocaleDateString();
            const score = (r.score * 100).toFixed(0);
            return `[${i + 1}] (${score}% match, ${date})\n${r.text}`;
          })
          .join("\n\n");

        return {
          content: [
            {
              type: "text" as const,
              text: `Found ${results.length} relevant memories:\n\n${formatted}`,
            },
          ],
        };
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        return {
          content: [
            {
              type: "text" as const,
              text: `Error searching memories: ${msg}`,
            },
          ],
        };
      }
    },
  );
}
```

Update `src/mcp-server/index.ts`:

- Add import: `import { registerMemoryTools } from './tools/memory.js';`
- Add call: `registerMemoryTools(server);` after registerCronTools

Pattern follows existing cron.ts structure:

- Zod schema for typed params
- Graceful error messages
- Text content response
  </action>
  <verify>
  `npm run build` succeeds
  MCP server lists search_memories tool:

```bash
node dist/mcp-server/index.js &
# Tool should be discoverable
```

  </verify>
  <done>
search_memories MCP tool registered, accepts query/limit/days_back params
  </done>
</task>

<task type="auto">
  <name>Task 3: End-to-end verification</name>
  <files>
    (none - verification only)
  </files>
  <action>
Verify complete flow:

1. Build and ensure no errors:

   ```bash
   npm run build
   ```

2. Check database has embeddings (or create test data):

   ```bash
   sqlite3 ~/.klausbot/klausbot.db "SELECT count(*) FROM embeddings"
   sqlite3 ~/.klausbot/klausbot.db "SELECT count(*) FROM vec_embeddings"
   ```

3. Test MCP server tool discovery:
   - Start MCP server: `node dist/mcp-server/index.js`
   - Verify search_memories appears in tool list

4. Integration test (manual or via Claude):
   - Claude calls `search_memories` with query
   - Results returned with text, score, date
   - Date filter works (days_back param)

5. Check no regressions:
   - Cron MCP tools still work
   - Gateway starts without error
   - Logger still stores embeddings (to SQLite now)

EXPECTED RESULTS:

- search_memories available as MCP tool
- Returns formatted memory results
- Date filtering works
- No regressions in existing functionality
  </action>
  <verify>
  All verification steps pass:
- Build succeeds
- Database has vec_embeddings entries
- MCP tool registered
- Search returns results
  </verify>
  <done>
  Phase 7.1 complete: embeddings in SQLite, searchable via MCP tool
  </done>
  </task>

</tasks>

<verification>
After all tasks:
1. `npm run build` - must pass
2. search_memories MCP tool available
3. Search returns relevant results with scores
4. Date filter (days_back) works
5. Existing cron tools still work
6. Gateway starts cleanly
</verification>

<success_criteria>

- semanticSearch uses sqlite-vec KNN queries
- search_memories MCP tool registered
- Claude can search past conversations
- Date-based filtering supported
- No regressions in cron tools or gateway
  </success_criteria>

<output>
After completion, create `.planning/phases/07.1-memory-search-mcp/07.1-02-SUMMARY.md`
</output>
