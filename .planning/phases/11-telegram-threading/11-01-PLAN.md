---
phase: 11-telegram-threading
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/daemon/queue.ts
  - src/daemon/gateway.ts
autonomous: true

must_haves:
  truths:
    - "Bot responses appear in same thread as user message (forum topics)"
    - "Bot responses show as replies to user's original message"
    - "Non-forum chats continue to work (undefined thread ID is handled)"
  artifacts:
    - path: "src/daemon/queue.ts"
      provides: "ThreadingContext interface and threading field in QueuedMessage"
      contains: "messageThreadId"
    - path: "src/daemon/gateway.ts"
      provides: "Threading extraction and pass-through to all response methods"
      contains: "reply_parameters"
  key_links:
    - from: "src/daemon/gateway.ts (message handlers)"
      to: "queue.add()"
      via: "threading context extraction"
      pattern: "ctx\\.msg\\.message_thread_id"
    - from: "src/daemon/gateway.ts (processMessage)"
      to: "bot.api.sendMessage"
      via: "reply_parameters and message_thread_id"
      pattern: "message_thread_id.*msg\\.threading"
---

<objective>
Implement Telegram threading support so bot responses stay in correct thread/topic and appear as visual replies to user messages.

Purpose: Conversations in forum-enabled chats stay organized; each response links back to the triggering message.
Output: Modified queue.ts with threading fields, modified gateway.ts with threading pass-through.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-telegram-threading/11-RESEARCH.md
@src/daemon/queue.ts
@src/daemon/gateway.ts
@src/telegram/streaming.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add threading context to queue</name>
  <files>src/daemon/queue.ts</files>
  <action>
1. Add `ThreadingContext` interface after `QueuedMessage` interface:
```typescript
/** Threading context for Telegram forum topics and reply linking */
export interface ThreadingContext {
  messageThreadId?: number;    // Forum topic thread ID
  replyToMessageId?: number;   // Original message to reply to
}
```

2. Add `threading?: ThreadingContext` field to `QueuedMessage` interface after `media?`.

3. Update `add()` method signature to accept optional threading parameter:
```typescript
add(
  chatId: number,
  text: string,
  media?: MediaAttachment[],
  threading?: ThreadingContext,
): string
```

4. In `add()` method body, include threading in the message object:
```typescript
const message: QueuedMessage = {
  id,
  chatId,
  text,
  timestamp: Date.now(),
  status: "pending",
  media,
  threading,
};
```
  </action>
  <verify>
`npx tsc --noEmit` passes (no type errors in queue.ts)
  </verify>
  <done>
QueuedMessage has threading field; add() accepts threading parameter; ThreadingContext exported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire threading through gateway</name>
  <files>src/daemon/gateway.ts</files>
  <action>
1. Add import for `ThreadingContext` from `./queue.js`.

2. Update `message:text` handler to extract and pass threading:
```typescript
bot.on("message:text", async (ctx: MyContext) => {
  const chatId = ctx.chat?.id;
  if (!chatId) return;

  const rawText = ctx.message?.text ?? "";
  if (!rawText.trim()) return;

  const text = translateSkillCommand(rawText);

  // Extract threading context
  const threading: ThreadingContext = {
    messageThreadId: ctx.msg.message_thread_id,
    replyToMessageId: ctx.msg.message_id,
  };

  const queueId = queue.add(chatId, text, undefined, threading);
  // ... rest unchanged
});
```

3. Update `message:voice` handler similarly - pass `threading` as 4th arg to `queue.add()`.

4. Update `message:photo` handler similarly - pass `threading` as 4th arg to `queue.add()`.

5. Update `splitAndSend()` signature to accept threading:
```typescript
async function splitAndSend(
  chatId: number,
  text: string,
  threading?: ThreadingContext,
): Promise<number>
```

6. In `splitAndSend()`, update the sendMessage call:
```typescript
await bot.api.sendMessage(chatId, chunk, {
  parse_mode: "HTML",
  message_thread_id: threading?.messageThreadId,
  // Only reply to original message for first chunk
  reply_parameters: i === 0 && threading?.replyToMessageId
    ? { message_id: threading.replyToMessageId }
    : undefined,
});
```
(Note: Need to track chunk index `i` in the loop)

7. In `processMessage()` streaming path, pass threading to `streamToTelegram()`:
```typescript
const streamResult = await streamToTelegram(
  bot,
  msg.chatId,
  effectiveText,
  streamConfig,
  {
    model: jsonConfig.model,
    additionalInstructions,
    messageThreadId: msg.threading?.messageThreadId,
  },
);
```

8. In streaming path, update final message sending:
```typescript
await splitAndSend(msg.chatId, streamResult.result, msg.threading);
```

9. In batch path, update response sending:
```typescript
const messages = await splitAndSend(msg.chatId, response.result, msg.threading);
```

10. Update error response in batch path to include threading:
```typescript
await bot.api.sendMessage(
  msg.chatId,
  `Error (Claude): ${response.result}`,
  {
    message_thread_id: msg.threading?.messageThreadId,
    reply_parameters: msg.threading?.replyToMessageId
      ? { message_id: msg.threading.replyToMessageId }
      : undefined,
  },
);
```

11. Update media error response to include threading (both streaming and batch paths).

12. Fallback plain text in splitAndSend should also include threading options.
  </action>
  <verify>
`npx tsc --noEmit` passes (no type errors).
`npm run dev -- daemon` starts without errors (smoke test - ctrl+c after startup).
  </verify>
  <done>
All message handlers extract threading; all response methods pass message_thread_id and reply_parameters; bot compiles and starts.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Daemon starts: `npm run dev -- daemon` (ctrl+c after "Gateway running")
3. Code inspection: grep for key patterns:
   - `message_thread_id` appears in queue.ts and gateway.ts
   - `reply_parameters` appears in gateway.ts sendMessage calls
   - `threading` parameter in queue.add() calls
</verification>

<success_criteria>
- [x] TELE-01: Bot respects message_thread_id for threaded conversations
  - Threading context stored in queue
  - message_thread_id passed to all sendMessage/sendMessageDraft calls
- [x] TELE-02: Replies are properly threaded
  - reply_parameters with message_id passed to responses
  - First chunk of split messages links as reply; subsequent chunks in-thread only
</success_criteria>

<output>
After completion, create `.planning/phases/11-telegram-threading/11-01-SUMMARY.md`
</output>
