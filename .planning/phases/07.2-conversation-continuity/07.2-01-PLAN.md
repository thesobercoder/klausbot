---
phase: 07.2-conversation-continuity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/hook.ts
  - src/index.ts
  - src/memory/logger.ts
autonomous: true

must_haves:
  truths:
    - "klausbot hook start|compact|end commands exist and accept stdin JSON"
    - "Markdown conversation logger removed from message processing"
    - "Hook handlers read stdin and can output to stdout"
  artifacts:
    - path: "src/cli/hook.ts"
      provides: "Hook CLI handlers for SessionStart, PreCompact, SessionEnd"
      exports: ["handleHookStart", "handleHookCompact", "handleHookEnd"]
    - path: "src/index.ts"
      provides: "hook subcommand registration"
      contains: "command('hook')"
  key_links:
    - from: "src/index.ts"
      to: "src/cli/hook.ts"
      via: "dynamic import"
      pattern: "import.*hook"
---

<objective>
Create hook CLI commands for Claude Code integration and remove redundant markdown logger.

Purpose: Foundation for conversation continuity - hooks receive transcript path from Claude CLI
Output: `klausbot hook start|compact|end` subcommands that read JSON from stdin
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.2-conversation-continuity/07.2-RESEARCH.md

Key patterns from existing code:
- CLI subcommands use Commander.js (see src/index.ts)
- Dynamic imports to avoid loading unnecessary modules
- silenceLogs() for CLI commands that shouldn't output logs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hook CLI handlers</name>
  <files>src/cli/hook.ts</files>
  <action>
Create new file with three hook handlers:

```typescript
/**
 * Hook CLI handlers for Claude Code integration
 * Receives JSON from stdin, processes session events
 */

import { stdin } from 'process';

/** Claude Code hook input structure */
interface HookInput {
  session_id: string;
  transcript_path: string;
  cwd: string;
  hook_event_name: string;
  source?: string;  // SessionStart: 'startup' | 'resume' | 'clear' | 'compact'
  reason?: string;  // SessionEnd: exit reason
}

/**
 * Read JSON from stdin (non-blocking with timeout)
 */
async function readStdin(timeoutMs = 5000): Promise<HookInput> {
  const chunks: Buffer[] = [];

  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error('stdin timeout'));
    }, timeoutMs);

    stdin.on('data', (chunk: Buffer) => {
      chunks.push(chunk);
    });

    stdin.on('end', () => {
      clearTimeout(timeout);
      try {
        const json = Buffer.concat(chunks).toString('utf-8');
        resolve(JSON.parse(json) as HookInput);
      } catch (err) {
        reject(new Error(`Invalid JSON: ${err}`));
      }
    });

    stdin.on('error', (err) => {
      clearTimeout(timeout);
      reject(err);
    });
  });
}

/**
 * Handle SessionStart hook
 * Outputs context to stdout (injected into Claude session)
 */
export async function handleHookStart(): Promise<void> {
  const input = await readStdin();

  // Output current datetime for temporal context
  const datetime = new Date().toISOString();

  // Placeholder for conversation summaries (Plan 02 will implement)
  const context = `<session-context>
Current datetime: ${datetime}
Session ID: ${input.session_id}
</session-context>`;

  // Write to stdout - Claude adds this to context
  console.log(context);
}

/**
 * Handle PreCompact hook
 * Saves conversation state before context window compaction
 */
export async function handleHookCompact(): Promise<void> {
  const input = await readStdin();

  // Placeholder: Plan 02 will save conversation state
  // For now, just log to stderr (hooks should be quiet on stdout)
  console.error(`[hook:compact] session=${input.session_id}`);
}

/**
 * Handle SessionEnd hook
 * Copies transcript to storage, generates summary
 */
export async function handleHookEnd(): Promise<void> {
  const input = await readStdin();

  // Placeholder: Plan 02 will implement storage
  // For now, just log to stderr
  console.error(`[hook:end] session=${input.session_id} transcript=${input.transcript_path}`);
}
```

Key points:
- stdin timeout prevents hanging if no input
- stdout for SessionStart context injection
- stderr for logging (won't pollute stdout)
- Placeholders for Plan 02 to fill in
  </action>
  <verify>TypeScript compiles: `npm run build`</verify>
  <done>src/cli/hook.ts exists with three exported handlers</done>
</task>

<task type="auto">
  <name>Task 2: Register hook subcommands in CLI</name>
  <files>src/index.ts</files>
  <action>
Add hook command group to CLI (similar to pairing subcommands pattern):

After the `mcp` command, add:

```typescript
// hook command (for Claude Code hooks)
const hook = program
  .command('hook')
  .description('Claude Code session hooks (internal)');

hook
  .command('start')
  .description('SessionStart hook - outputs context to stdout')
  .action(async () => {
    silenceLogs();
    const { handleHookStart } = await import('./cli/hook.js');
    await handleHookStart();
  });

hook
  .command('compact')
  .description('PreCompact hook - saves state before compaction')
  .action(async () => {
    silenceLogs();
    const { handleHookCompact } = await import('./cli/hook.js');
    await handleHookCompact();
  });

hook
  .command('end')
  .description('SessionEnd hook - stores transcript and summary')
  .action(async () => {
    silenceLogs();
    const { handleHookEnd } = await import('./cli/hook.js');
    await handleHookEnd();
  });
```

Use silenceLogs() for all hooks - they should not emit pino logs.
  </action>
  <verify>
Commands appear in help: `npx tsx src/index.ts hook --help`
Shows: start, compact, end subcommands
  </verify>
  <done>klausbot hook start|compact|end commands registered and callable</done>
</task>

<task type="auto">
  <name>Task 3: Remove markdown logger calls from gateway</name>
  <files>src/daemon/gateway.ts, src/memory/logger.ts</files>
  <action>
Remove logUserMessage and logAssistantMessage calls from gateway.ts:

1. In gateway.ts imports, remove:
   - logUserMessage
   - logAssistantMessage

2. In processMessage(), remove these lines:
   - `logUserMessage(msg.text);` (around line 481)
   - `logUserMessage(\`[Image: ${m.localPath}]\`);` (around line 497)
   - `logAssistantMessage(response.result);` (around line 550)

3. In src/memory/logger.ts:
   - Add deprecation comment at top:
   ```typescript
   /**
    * @deprecated Markdown logger - replaced by SQLite conversation storage in 07.2
    * Kept for reference only. Will be removed in future cleanup.
    */
   ```
   - Do NOT delete the file yet (Plan 02 may reference patterns)

Key: Messages will now ONLY be stored via SessionEnd hook (Plan 02).
  </action>
  <verify>
Build succeeds: `npm run build`
grep confirms no logUserMessage/logAssistantMessage in gateway: `grep -n "logUserMessage\|logAssistantMessage" src/daemon/gateway.ts`
  </verify>
  <done>Markdown logging removed from message processing flow</done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build`
2. Hook commands work: `echo '{"session_id":"test","transcript_path":"/tmp/test.jsonl","cwd":"/tmp","hook_event_name":"SessionStart"}' | npx tsx src/index.ts hook start`
   - Should output `<session-context>` with datetime
3. Compact/end hooks run: similar test with respective commands
4. Gateway starts: `npx tsx src/index.ts daemon` (Ctrl+C after startup)
5. No logger calls in gateway: `grep -c "logUserMessage\|logAssistantMessage" src/daemon/gateway.ts` returns 0
</verification>

<success_criteria>
- klausbot hook start outputs session context to stdout
- klausbot hook compact|end accept stdin and log to stderr
- Markdown logger removed from gateway message flow
- Build succeeds, existing functionality unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/07.2-conversation-continuity/07.2-01-SUMMARY.md`
</output>
