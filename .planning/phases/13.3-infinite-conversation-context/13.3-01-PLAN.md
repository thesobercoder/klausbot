---
phase: 13.3-infinite-conversation-context
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/memory/conversations.ts
  - src/memory/context.ts
  - src/memory/index.ts
autonomous: true

must_haves:
  truths:
    - "Conversations queryable by chatId within time windows (30min, 4hr, 24hr, 7d)"
    - "Full transcripts formatted as XML with timestamps and relative time labels"
    - "Summaries used for older conversations beyond today"
    - "Total injected context stays within 120K character budget (~30K tokens)"
    - "Thread detection distinguishes continuation (<30min gap) from new conversation"
    - "Retrieval instructions assertively enforce search-first behavior"
  artifacts:
    - path: "src/memory/conversations.ts"
      provides: "getConversationsForContext() query method"
      exports: ["getConversationsForContext"]
    - path: "src/memory/context.ts"
      provides: "buildConversationContext() + thread detection + updated retrieval instructions"
      exports: ["buildConversationContext"]
    - path: "src/memory/index.ts"
      provides: "Re-exports buildConversationContext"
      contains: "buildConversationContext"
  key_links:
    - from: "src/memory/context.ts"
      to: "src/memory/conversations.ts"
      via: "getConversationsForContext() import"
      pattern: "getConversationsForContext"
    - from: "buildConversationContext"
      to: "parseTranscript"
      via: "transcript parsing for full-text injection"
      pattern: "parseTranscript"
---

<objective>
Build conversation context engine: query layer, thread detection, tiered formatting, and retrieval instruction rewrite.

Purpose: This is the core logic for Phase 13.3 — everything that builds the conversation history XML block and detects thread continuations. Plan 02 wires this into the gateway.

Output: `buildConversationContext(chatId)` function returning XML-tagged conversation history with thread status, plus rewritten retrieval instructions.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13.3-infinite-conversation-context/13.3-RESEARCH.md

@src/memory/conversations.ts
@src/memory/context.ts
@src/memory/schema.ts
@src/memory/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Conversation query layer + context builder with thread detection</name>
  <files>src/memory/conversations.ts, src/memory/context.ts, src/memory/index.ts</files>
  <action>
**In `src/memory/conversations.ts`:**

Add `getConversationsForContext(chatId: number, limitChars?: number)` function that:

1. Queries conversations table filtered by `chatId`, ordered by `endedAt DESC`
2. Fetches conversations from last 7 days (sufficient window for tiered injection)
3. Returns array of `ConversationRecord` objects
4. Uses existing drizzle query patterns (see `getRecentConversations` for reference)
5. Add `gte` condition: `gte(conversations.endedAt, sevenDaysAgo.toISOString())`
6. No limit param — fetch all within 7 days, let the context builder handle budgeting

Export `getConversationsForContext` from the module.

**In `src/memory/context.ts`:**

Add these constants at top of file:

```typescript
const ACTIVE_THREAD_WINDOW_MS = 30 * 60 * 1000; // 30 minutes
const RECENT_WINDOW_MS = 4 * 60 * 60 * 1000; // 4 hours
const TODAY_WINDOW_MS = 24 * 60 * 60 * 1000; // 24 hours
const MAX_CONTEXT_CHARS = 120_000; // ~30K tokens at 4:1 ratio
```

Add `buildConversationContext(chatId: number): string` function that:

1. **Query**: Calls `getConversationsForContext(chatId)` to get last 7 days of conversations for this chat
2. **Thread detection**: Checks if most recent conversation ended within `ACTIVE_THREAD_WINDOW_MS` (30min). If yes: `isContinuation = true`. If no: `isContinuation = false`.
3. **Tier assignment**: Categorize each conversation:
   - Tier 1 (FULL): Active thread conversations (within 30min chain — walk backward from most recent, including any conversations that are within 30min of each other)
   - Tier 2 (FULL): Today's other conversations (within 24hr but not active thread)
   - Tier 3 (SUMMARY): Yesterday's conversations
   - Tier 4 (SUMMARY): Older conversations (2-7 days)
4. **Format each conversation**:
   - FULL format: Parse transcript via `parseTranscript()`, filter to `user` and `assistant` types only, extract text via content array (handle both string and array content — see `extractConversationText` pattern). Format as:
     ```
     <conversation timestamp="ISO" relative="today|yesterday|Mon|Tue...">
     [human TIME] message text
     [you TIME] response text
     </conversation>
     ```
     TIME = `HH:MM` from entry timestamp (use `toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false })`)
   - SUMMARY format: `<conversation timestamp="ISO" relative="LABEL" summary="true">\nSummary: {conv.summary}\n</conversation>`
5. **Budget enforcement**: Track character count. Add conversations in priority order (Tier 1 first, then 2, 3, 4). Stop adding when `MAX_CONTEXT_CHARS` would be exceeded. If a single Tier 1 conversation exceeds budget, truncate its messages from the oldest end.
6. **Thread status**: Prepend a thread status tag:
   - Continuation: `<thread-status>CONTINUATION — You are in an ongoing conversation. The user just messaged again. Do NOT greet or reintroduce yourself. Pick up naturally where you left off.</thread-status>`
   - New: `<thread-status>NEW CONVERSATION — This is a new conversation or a return after a break.</thread-status>`
7. **Relative time labels**: Use helper function `getRelativeTimeLabel(dateStr: string): string`:
   - Same calendar day as now → "today"
   - Previous calendar day → "yesterday"
   - Else → day name ("Monday", "Tuesday", etc.) if within 7 days
8. **Wrap everything** in `<conversation-history>\n...\n</conversation-history>`
9. **Return empty string** if no conversations found (first-ever message)

Import `parseTranscript` from `./conversations.js` and `getConversationsForContext` from `./conversations.js`.

**In `src/memory/index.ts`:**

Add export: `export { buildConversationContext } from "./context.js";`
</action>
<verify>
Run `npm run check` — TypeScript compiles, no lint errors. Verify the new exports exist:

```
grep -n "buildConversationContext" src/memory/context.ts src/memory/index.ts
grep -n "getConversationsForContext" src/memory/conversations.ts src/memory/index.ts
```

  </verify>
  <done>
`buildConversationContext(chatId)` returns XML-tagged conversation history with thread detection, tiered formatting (full/summary), relative time labels, and 120K char budget enforcement. `getConversationsForContext(chatId)` queries last 7 days of conversations. Both compile and export cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite retrieval instructions for search-first enforcement</name>
  <files>src/memory/context.ts</files>
  <action>
Modify `getRetrievalInstructions()` in `src/memory/context.ts`. The current text is passive ("When in doubt, search."). Replace the `## Memory via MCP Tools` section with assertive search-first language.

Replace these specific parts:

**Current** (lines ~106-124):

```
## Memory via MCP Tools

You may have recent conversation summaries injected at session start - but that's just a glimpse.
Your FULL history is available via MCP tools with NO time limit.

**Tools:**
- **search_memories** - Search ALL past conversations and memories (semantic + keyword)
- **get_conversation** - Retrieve complete transcript by session_id

**When to use:**
- User references the past: "we talked about", "remember when", "what did I say about"
- User asks about something you should know but don't see in context
- Anything that might have been discussed before - search first, don't guess
- When injected summaries seem incomplete - there's always more

**How to use:**
1. search_memories with relevant query (returns summaries + session IDs)
2. If you need full details, get_conversation with session_id from results
3. Go as far back as needed - weeks, months, everything is searchable

Don't assume context is complete. When in doubt, search.
```

**New:**

```
## Memory via MCP Tools

You have recent conversation history injected above. But your FULL history goes back weeks and months via MCP tools.

**Tools:**
- **search_memories** - Search ALL past conversations and memories (semantic + keyword)
- **get_conversation** - Retrieve complete transcript by session_id

**MANDATORY: Search Before Claiming Ignorance**

BEFORE saying "I don't know", "I don't have context", or "I'm not sure":
1. Call search_memories with the relevant topic
2. If results reference a conversation, call get_conversation for full details
3. ONLY after searching and finding nothing may you say you don't know

**This is a FAILURE:**
- User: "What did we decide about X?"
- You: "I don't have context about that." (WITHOUT searching first)

**This is CORRECT:**
- User: "What did we decide about X?"
- You: *calls search_memories("X decision")* → finds session → *calls get_conversation* → answers from history

You have weeks of conversation history. Use it. Never claim you don't remember without searching first.
```

Keep the rest of `getRetrievalInstructions()` unchanged (Persona, CRITICAL: Always Respond With Text, Working Directory, Identity Files, Learning and Memory, etc.).
</action>
<verify>
Run `npm run check` — compiles clean. Verify the new text:

```
grep -n "MANDATORY.*Search" src/memory/context.ts
grep -n "FAILURE" src/memory/context.ts
```

  </verify>
  <done>
Retrieval instructions now assertively enforce search-first behavior. "MANDATORY: Search Before Claiming Ignorance" section replaces passive "When in doubt, search." language. Claude is instructed that responding without searching is a failure.
  </done>
</task>

</tasks>

<verification>
1. `npm run check` passes (typecheck + lint + format verification)
2. `buildConversationContext` is exported from `src/memory/index.ts`
3. `getConversationsForContext` is exported from `src/memory/conversations.ts`
4. Retrieval instructions contain "MANDATORY" and "FAILURE" enforcement language
5. Thread detection constants defined: `ACTIVE_THREAD_WINDOW_MS`, `MAX_CONTEXT_CHARS`
</verification>

<success_criteria>

- `buildConversationContext(chatId)` returns well-formed XML with `<conversation-history>`, `<thread-status>`, and `<conversation>` tags
- Tiered formatting applies: full transcripts for active thread + today, summaries for yesterday + older
- Token budget enforced at 120K characters
- Retrieval instructions rewritten with assertive search-first language
- All TypeScript compiles, lint passes
  </success_criteria>

<output>
After completion, create `.planning/phases/13.3-infinite-conversation-context/13.3-01-SUMMARY.md`
</output>
