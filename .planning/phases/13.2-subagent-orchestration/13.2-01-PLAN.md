---
phase: 13.2-subagent-orchestration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/daemon/spawner.ts
  - src/telegram/streaming.ts
  - src/memory/context.ts
  - src/memory/index.ts
  - src/config/schema.ts
  - src/daemon/gateway.ts
autonomous: true

must_haves:
  truths:
    - "Claude can spawn background subagents via Task tool"
    - "Subagent results return to parent Claude"
    - "Parent and child agents share coordination via CLAUDE_CODE_TASK_LIST_ID"
    - "Claude receives guidance on when and how to use subagents"
  artifacts:
    - path: "src/daemon/spawner.ts"
      provides: "Task tool enablement via --allowedTools flag"
      contains: "enableSubagents"
    - path: "src/memory/context.ts"
      provides: "Orchestration instructions function"
      contains: "getOrchestrationInstructions"
    - path: "src/config/schema.ts"
      provides: "Subagents config section"
      contains: "subagents"
  key_links:
    - from: "src/daemon/spawner.ts"
      to: "claude CLI"
      via: "--allowedTools Task flag"
      pattern: 'allowedTools.*Task'
    - from: "src/daemon/gateway.ts"
      to: "src/daemon/spawner.ts"
      via: "enableSubagents option"
      pattern: "enableSubagents.*true"
    - from: "src/memory/context.ts"
      to: "src/daemon/gateway.ts"
      via: "getOrchestrationInstructions() appended to additionalInstructions"
      pattern: "getOrchestrationInstructions.*additionalInstructions|orchestrationInstructions"
---

<objective>
Enable Claude to spawn and coordinate background Claude subagents using Claude Code's native Task tool.

Purpose: Allow klausbot's Claude instance to delegate work to parallel subagents for research, exploration, and complex multi-step tasks.

Output: Modified spawner with Task tool support, orchestration instructions in system prompt, and configurable subagent settings.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13.2-subagent-orchestration/13.2-RESEARCH.md

Key research findings:
- Claude Code has built-in Task tool for subagent orchestration
- Enable via `--allowedTools "Task"` flag to claude CLI
- Set `CLAUDE_CODE_TASK_LIST_ID` env var for multi-session coordination
- Subagents start fresh (pass context via prompt parameter)
- Single-level only (subagents cannot spawn subagents)
- Background agents auto-deny permission prompts (use --dangerously-skip-permissions)

Task tool result handling (from official docs):
- Task tool is synchronous for foreground agents: returns result directly to parent
- Task tool is asynchronous for background agents: parent checks completion via /tasks
- Result collection is built into Task tool - no custom IPC needed
- Only summary returns to parent (context isolation preserved)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable Task tool in spawner</name>
  <files>
    - src/daemon/spawner.ts
    - src/telegram/streaming.ts
  </files>
  <action>
Modify spawner.ts:

1. Update `SpawnerOptions` interface:
```typescript
export interface SpawnerOptions {
  timeout?: number;
  model?: string;
  additionalInstructions?: string;
  enableSubagents?: boolean;  // NEW: opt-in to Task tool
  taskListId?: string;        // NEW: for multi-session coordination
}
```

2. In `queryClaudeCode()`, add args building logic:
```typescript
// Enable Task tool if requested (after existing args)
if (options.enableSubagents) {
  args.push("--allowedTools", "Task");
}
```

3. Update spawn environment:
```typescript
const env = { ...process.env };
if (options.taskListId) {
  env.CLAUDE_CODE_TASK_LIST_ID = options.taskListId;
}

const claude = spawn("claude", args, {
  stdio: ["inherit", "pipe", "pipe"],
  cwd: KLAUSBOT_HOME,
  env,  // Use env variable instead of inline process.env
});
```

Modify streaming.ts:

1. Update `StreamOptions` interface to match:
```typescript
export interface StreamOptions {
  model?: string;
  additionalInstructions?: string;
  signal?: AbortSignal;
  enableSubagents?: boolean;  // NEW
  taskListId?: string;        // NEW
}
```

2. In `streamClaudeResponse()`, add same args/env logic:
```typescript
if (options.enableSubagents) {
  args.push("--allowedTools", "Task");
}

const env = { ...process.env };
if (options.taskListId) {
  env.CLAUDE_CODE_TASK_LIST_ID = options.taskListId;
}
```

3. Update spawn call to use env variable.
  </action>
  <verify>
TypeScript compiles without errors: `npm run build`
  </verify>
  <done>
SpawnerOptions and StreamOptions have enableSubagents and taskListId fields.
Both spawners conditionally add --allowedTools Task and set CLAUDE_CODE_TASK_LIST_ID.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add orchestration instructions to system prompt</name>
  <files>
    - src/memory/context.ts
    - src/memory/index.ts
  </files>
  <action>
Add to context.ts (after getAgentReminder function):

```typescript
/**
 * Get orchestration instructions for subagent spawning
 * Tells Claude how to use Task tool for parallel work
 *
 * @returns Orchestration instructions wrapped in XML tags
 */
export function getOrchestrationInstructions(): string {
  return `<subagent-orchestration>
## Spawning Subagents

You can delegate work to subagents using the Task tool.

### When to use:
- Parallel research (spawn multiple, synthesize results)
- Context isolation (keep verbose output out of main context)
- Specialized tasks (use Explore for codebase analysis)
- Long-running operations that benefit from focused attention

### Task tool parameters:
- subagent_type: "Explore" | "Plan" | "general-purpose" | custom agent name
- description: Brief task description (3-5 words)
- prompt: Full instructions (include all needed context)
- run_in_background: true for async, false for blocking
- model: "haiku" (fast/cheap), "sonnet" (balanced), "opus" (capable)

### Example - parallel research:
<invoke name="Task">
  <parameter name="subagent_type">Explore</parameter>
  <parameter name="description">Analyze auth module</parameter>
  <parameter name="prompt">Search for authentication patterns in the codebase. Return: key files, patterns used, potential issues. Max 300 words.</parameter>
  <parameter name="run_in_background">true</parameter>
  <parameter name="model">haiku</parameter>
</invoke>

### Important constraints:
- Subagents start fresh (pass all context via prompt)
- Single level only (subagents cannot spawn subagents)
- Background agents cannot ask questions (provide complete instructions)
- Instruct agents to return concise summaries to avoid context pollution
</subagent-orchestration>`;
}
```

Update index.ts exports:

Add `getOrchestrationInstructions` to the export list from context.ts.
  </action>
  <verify>
TypeScript compiles without errors: `npm run build`
Grep confirms function exists: `grep -n "getOrchestrationInstructions" src/memory/context.ts`
  </verify>
  <done>
getOrchestrationInstructions() function exists in context.ts.
Function is exported from src/memory/index.ts.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add config schema and wire to gateway</name>
  <files>
    - src/config/schema.ts
    - src/daemon/gateway.ts
  </files>
  <action>
Update schema.ts:

Add subagents section to jsonConfigSchema (after heartbeat section):

```typescript
/** Subagent orchestration configuration */
subagents: z
  .object({
    /** Enable Task tool for subagent spawning (default: true) */
    enabled: z.boolean().default(true),
    /** Task list ID prefix for multi-session coordination */
    taskListIdPrefix: z.string().default("klausbot"),
  })
  .default({ enabled: true, taskListIdPrefix: "klausbot" }),
```

Update gateway.ts:

1. Import getOrchestrationInstructions from memory:
```typescript
import {
  // ... existing imports ...
  getOrchestrationInstructions,
} from "../memory/index.js";
```

2. In processMessage(), generate task list ID per session:
```typescript
// Generate unique task list ID for this session (after config read)
const subagentsConfig = jsonConfig.subagents ?? { enabled: true, taskListIdPrefix: "klausbot" };
const taskListId = subagentsConfig.enabled
  ? `${subagentsConfig.taskListIdPrefix}-${msg.chatId}-${Date.now()}`
  : undefined;
```

3. When subagents enabled, append orchestration instructions:
```typescript
// Add orchestration instructions if subagents enabled (before isBootstrap check for additionalInstructions)
let orchestrationInstructions = "";
if (subagentsConfig.enabled) {
  orchestrationInstructions = "\n\n" + getOrchestrationInstructions();
}

// Then in additionalInstructions building:
const additionalInstructions = isBootstrap
  ? chatIdContext + "\n\n" + BOOTSTRAP_INSTRUCTIONS
  : chatIdContext + noteInstructions + orchestrationInstructions;
```

4. Pass enableSubagents to both stream and batch paths:

For streaming path (streamToTelegram call options):
```typescript
{
  model: jsonConfig.model,
  additionalInstructions,
  messageThreadId: msg.threading?.messageThreadId,
  enableSubagents: subagentsConfig.enabled,
  taskListId,
}
```

For batch path (queryClaudeCode call):
```typescript
const response = await queryClaudeCode(effectiveText, {
  additionalInstructions,
  model: jsonConfig.model,
  enableSubagents: subagentsConfig.enabled,
  taskListId,
});
```

5. Update StreamToTelegramOptions interface in streaming.ts to include the new fields:
```typescript
export interface StreamToTelegramOptions {
  model?: string;
  additionalInstructions?: string;
  messageThreadId?: number;
  enableSubagents?: boolean;  // NEW
  taskListId?: string;        // NEW
}
```

6. Wire options through streamToTelegram to streamClaudeResponse.
  </action>
  <verify>
TypeScript compiles: `npm run build`
Config schema includes subagents: `grep -n "subagents" src/config/schema.ts`
Gateway imports orchestration: `grep -n "getOrchestrationInstructions" src/daemon/gateway.ts`
Gateway wires to additionalInstructions: `grep -n "orchestrationInstructions" src/daemon/gateway.ts`
  </verify>
  <done>
jsonConfigSchema has subagents section with enabled and taskListIdPrefix fields.
Gateway reads subagents config and generates per-session task list IDs.
Orchestration instructions appended to additionalInstructions when enabled.
enableSubagents and taskListId passed to both streaming and batch spawners.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build`
2. Spawner has Task tool support: `grep -A 5 "enableSubagents" src/daemon/spawner.ts`
3. Streaming has Task tool support: `grep -A 5 "enableSubagents" src/telegram/streaming.ts`
4. Orchestration instructions exist: `grep -n "subagent-orchestration" src/memory/context.ts`
5. Config schema updated: `grep -A 10 "subagents:" src/config/schema.ts`
6. Gateway wires everything: `grep -n "taskListId\|enableSubagents\|orchestrationInstructions" src/daemon/gateway.ts`

REQ-02 verification (subagent results return to parent):
- Task tool natively handles result return (no custom IPC needed)
- Per Claude Code docs: foreground agents return directly, background agents via /tasks
- This is built-in to Claude Code - verified by research phase
- See: .planning/phases/13.2-subagent-orchestration/13.2-RESEARCH.md "Context Isolation Model"
</verification>

<success_criteria>
1. `npm run build` completes without TypeScript errors
2. SpawnerOptions and StreamOptions have enableSubagents and taskListId fields
3. Both spawner functions conditionally add --allowedTools Task flag
4. Both spawner functions conditionally set CLAUDE_CODE_TASK_LIST_ID env var
5. getOrchestrationInstructions() function returns XML-wrapped instructions
6. jsonConfigSchema has subagents.enabled and subagents.taskListIdPrefix
7. Gateway passes subagent config to both streaming and batch paths
8. Task list ID is unique per chat session (includes chatId + timestamp)
</success_criteria>

<output>
After completion, create `.planning/phases/13.2-subagent-orchestration/13.2-01-SUMMARY.md`
</output>
