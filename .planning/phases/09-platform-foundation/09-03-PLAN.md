---
phase: 09-platform-foundation
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - src/config/schema.ts
  - src/config/loader.ts
  - src/config/json.ts
  - src/config/index.ts
  - src/cli/config.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Env vars hold secrets only (TELEGRAM_BOT_TOKEN, OPENAI_API_KEY)"
    - "JSON config holds non-secrets (model, logVerbosity, preferences)"
    - "Invalid JSON config causes startup failure with clear error"
    - "Unknown keys in JSON config cause startup failure (strict mode)"
    - "klausbot config validate shows env and JSON config status"
    - "Config hot-reloads on file change (mtime check)"
  artifacts:
    - path: "src/config/schema.ts"
      provides: "Env and JSON config schemas"
      exports: ["envSchema", "jsonConfigSchema", "EnvConfig", "JsonConfig"]
    - path: "src/config/json.ts"
      provides: "JSON config loader with hot reload"
      exports: ["loadJsonConfig", "getJsonConfig", "JSON_CONFIG_PATH"]
    - path: "src/cli/config.ts"
      provides: "Config validate CLI command"
      exports: ["runConfigValidate"]
  key_links:
    - from: "src/config/json.ts"
      to: "~/.klausbot/config/klausbot.json"
      via: "readFileSync with mtime cache"
      pattern: "readFileSync.*klausbot\\.json"
    - from: "src/cli/config.ts"
      to: "src/config/schema.ts"
      via: "safeParse validation"
      pattern: "safeParse"
    - from: "src/index.ts"
      to: "src/cli/config.ts"
      via: "commander subcommand"
      pattern: "command.*config.*validate"
---

<objective>
Implement 12-factor compliant config separation with hot reload and validation command.

Purpose: Secrets in env vars, non-secrets in JSON config. Clear validation and hot reload support.
Output: Split config system with validation CLI command.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-platform-foundation/09-CONTEXT.md
@.planning/phases/09-platform-foundation/09-RESEARCH.md
@src/config/schema.ts
@src/config/loader.ts
@src/cli/theme.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update config schemas for separation</name>
  <files>src/config/schema.ts</files>
  <action>
Update `src/config/schema.ts`:

1. Rename existing `configSchema` to `envSchema` (secrets only):

   ```typescript
   export const envSchema = z.object({
     TELEGRAM_BOT_TOKEN: z.string().min(1, "TELEGRAM_BOT_TOKEN is required"),
     OPENAI_API_KEY: z.string().optional(),
     LOG_LEVEL: z
       .enum(["silent", "trace", "debug", "info", "warn", "error", "fatal"])
       .default("info"),
     DATA_DIR: z.string().default("./data"),
   });
   export type EnvConfig = z.infer<typeof envSchema>;
   ```

2. Add JSON config schema (non-secrets, strict mode):

   ```typescript
   export const jsonConfigSchema = z
     .object({
       model: z.string().default("claude-sonnet-4-20250514"),
       logVerbosity: z.enum(["minimal", "normal", "verbose"]).default("normal"),
       preferences: z
         .object({
           timezone: z.string().optional(),
           language: z.string().default("en"),
         })
         .default({}),
     })
     .strict(); // Fail on unknown keys
   export type JsonConfig = z.infer<typeof jsonConfigSchema>;
   ```

3. Keep backward-compatible export:
   ```typescript
   // Backward compatibility - existing code uses configSchema
   export const configSchema = envSchema;
   export type Config = EnvConfig;
   ```
     </action>
     <verify>
       - `npx tsc --noEmit` passes
       - Existing imports of configSchema/Config still work
     </verify>
     <done>
   Config schemas split into env (secrets) and JSON (non-secrets) with strict mode.
     </done>
   </task>

<task type="auto">
  <name>Task 2: Create JSON config loader with hot reload</name>
  <files>src/config/json.ts, src/config/index.ts</files>
  <action>
Create `src/config/json.ts`:

1. Define config path:

   ```typescript
   import { homedir } from "os";
   import { join } from "path";
   export const JSON_CONFIG_PATH = join(
     homedir(),
     ".klausbot",
     "config",
     "klausbot.json",
   );
   ```

2. Implement cache with mtime checking:

   ```typescript
   let configCache: JsonConfig | null = null;
   let configMtime: number = 0;
   ```

3. Implement `loadJsonConfig(): JsonConfig`:
   - Check if file exists (existsSync)
   - If not exists: return defaults (jsonConfigSchema.parse({}))
   - If exists:
     - Check mtime with statSync
     - If cache valid (same mtime): return cache
     - Read file, JSON.parse, validate with jsonConfigSchema.parse()
     - Update cache and mtime
     - Return validated config
   - On parse/validation error: throw with clear message

4. Implement `getJsonConfig(): JsonConfig`:
   - Simply calls loadJsonConfig() (mtime check makes it cheap)
   - Used by application code for hot reload support

5. Export JSON_CONFIG_PATH for use by validation command

Update `src/config/index.ts`:

- Re-export from json.ts: { loadJsonConfig, getJsonConfig, JSON_CONFIG_PATH }
- Keep existing exports (config, loadConfig)
  </action>
  <verify> - `npx tsc --noEmit` passes - `npx tsx -e "import { getJsonConfig } from './src/config/index.js'; console.log(getJsonConfig())"` shows defaults
  </verify>
  <done>
  JSON config loader exists with hot reload via mtime checking.
  </done>
  </task>

<task type="auto">
  <name>Task 3: Create config validate CLI command</name>
  <files>src/cli/config.ts, src/index.ts</files>
  <action>
Create `src/cli/config.ts`:

1. Import theme from './theme.js'
2. Import { envSchema, jsonConfigSchema } from '../config/schema.js'
3. Import { JSON_CONFIG_PATH } from '../config/json.js'
4. Import { existsSync, readFileSync } from 'fs'

5. Implement `runConfigValidate(): void`:

   ```typescript
   export function runConfigValidate(): void {
     theme.blank();
     theme.header("Config Validation");
     theme.blank();

     // 1. Validate environment variables
     theme.muted("Checking environment variables...");
     const envResult = envSchema.safeParse(process.env);

     if (envResult.success) {
       theme.success("Environment variables: valid");
     } else {
       theme.error("Environment variables: invalid");
       for (const issue of envResult.error.issues) {
         theme.muted(`  - ${issue.path.join(".")}: ${issue.message}`);
       }
     }

     theme.blank();

     // 2. Validate JSON config
     theme.muted(`Checking config file: ${JSON_CONFIG_PATH}`);

     if (!existsSync(JSON_CONFIG_PATH)) {
       theme.info("Config file not found (using defaults)");
     } else {
       try {
         const raw = readFileSync(JSON_CONFIG_PATH, "utf8");
         const parsed = JSON.parse(raw);
         const configResult = jsonConfigSchema.safeParse(parsed);

         if (configResult.success) {
           theme.success("Config file: valid");
         } else {
           theme.error("Config file: invalid");
           for (const issue of configResult.error.issues) {
             theme.muted(`  - ${issue.path.join(".")}: ${issue.message}`);
           }
         }
       } catch (err) {
         theme.error("Config file: parse error");
         theme.muted(`  ${err instanceof Error ? err.message : String(err)}`);
       }
     }

     theme.blank();

     // Exit with error if env validation failed
     if (!envResult.success) {
       process.exit(1);
     }
   }
   ```

Update `src/index.ts`:

1. Add config command group:

   ```typescript
   const configCmd = program
     .command("config")
     .description("Configuration management");

   configCmd
     .command("validate")
     .description("Validate environment and config file")
     .action(async () => {
       silenceLogs();
       const { runConfigValidate } = await import("./cli/config.js");
       runConfigValidate();
     });
   ```

2. Place after existing commands (pairing, hook, etc.)
   </action>
   <verify> - `npx tsc --noEmit` passes - `npx tsx src/index.ts config validate` shows validation output - Without TELEGRAM_BOT_TOKEN: shows error, exits 1
   </verify>
   <done>
   `klausbot config validate` command exists and validates both env vars and JSON config.
   </done>
   </task>

</tasks>

<verification>
1. `npx tsc --noEmit` - No TypeScript errors
2. `npx tsx src/index.ts config validate` - Shows validation for env and JSON
3. Create invalid JSON config, re-run validate - Shows error
4. Gateway still starts correctly with existing env-only config
5. Help shows new config command: `npx tsx src/index.ts --help`
</verification>

<success_criteria>

- Config schemas separated: env for secrets, JSON for non-secrets
- JSON config validates with strict mode (unknown keys fail)
- Hot reload via mtime checking works
- `klausbot config validate` command shows clear status
- Backward compatibility maintained for existing code
  </success_criteria>

<output>
After completion, create `.planning/phases/09-platform-foundation/09-03-SUMMARY.md`
</output>
