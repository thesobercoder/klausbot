---
phase: 07.2-conversation-continuity
plan: 04
type: execute
wave: 3
depends_on: ["07.2-02"]
files_modified:
  - src/mcp-server/tools/memory.ts
  - src/mcp-server/tools/conversations.ts
  - src/mcp-server/index.ts
  - src/memory/search.ts
autonomous: true

must_haves:
  truths:
    - "search_memories tool searches both embeddings AND conversation summaries"
    - "get_conversation tool retrieves full transcript by session_id"
    - "Conversation results include session_id for drilling down"
  artifacts:
    - path: "src/mcp-server/tools/conversations.ts"
      provides: "get_conversation MCP tool"
      exports: ["registerConversationTools"]
    - path: "src/memory/search.ts"
      provides: "searchConversations function"
      exports: ["searchConversations"]
  key_links:
    - from: "src/mcp-server/tools/memory.ts"
      to: "src/memory/search.ts"
      via: "searchConversations import"
      pattern: "searchConversations"
---

<objective>
Extend MCP tools to search conversation history and retrieve transcripts.

Purpose: Claude can find and read past conversations via MCP tools
Output: Enhanced search_memories + new get_conversation tool
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07.2-conversation-continuity/07.2-RESEARCH.md
@.planning/phases/07.2-conversation-continuity/07.2-02-SUMMARY.md

Existing patterns:
- MCP tool registration in src/mcp-server/tools/memory.ts
- registerXTools(server) pattern
- createMcpLogger for MCP-specific logging
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add conversation search function</name>
  <files>src/memory/search.ts</files>
  <action>
Add searchConversations function to search.ts:

```typescript
import { desc, gte, like } from 'drizzle-orm';
import { getDrizzle } from './db.js';
import { conversations } from './schema.js';

/** Conversation search result */
export interface ConversationSearchResult {
  sessionId: string;
  summary: string;
  endedAt: string;
  messageCount: number;
  score: number;  // Relevance score (0-1)
}

/**
 * Search conversations by summary content
 * Uses SQL LIKE for keyword matching (semantic search for conversations in future)
 *
 * @param query - Search query
 * @param options - Search options
 * @returns Matching conversations with relevance scores
 */
export function searchConversations(
  query: string,
  options: { topK?: number; daysBack?: number } = {}
): ConversationSearchResult[] {
  const { topK = 5, daysBack } = options;
  const db = getDrizzle();

  // Build base query
  let results;
  const queryWords = query.toLowerCase().split(/\s+/).filter(w => w.length > 2);

  if (daysBack) {
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - daysBack);

    results = db
      .select()
      .from(conversations)
      .where(gte(conversations.endedAt, cutoff.toISOString()))
      .orderBy(desc(conversations.endedAt))
      .limit(50)  // Get more for filtering
      .all();
  } else {
    results = db
      .select()
      .from(conversations)
      .orderBy(desc(conversations.endedAt))
      .limit(50)
      .all();
  }

  // Score results by keyword match in summary
  const scored = results.map(conv => {
    const summaryLower = conv.summary.toLowerCase();
    const matchedWords = queryWords.filter(w => summaryLower.includes(w));
    const score = queryWords.length > 0
      ? matchedWords.length / queryWords.length
      : 0;

    return {
      sessionId: conv.sessionId,
      summary: conv.summary,
      endedAt: conv.endedAt,
      messageCount: conv.messageCount,
      score,
    };
  });

  // Filter and sort by score
  return scored
    .filter(r => r.score > 0)
    .sort((a, b) => b.score - a.score)
    .slice(0, topK);
}
```

Add export to existing semanticSearch:
```typescript
// At end of file, after semanticSearch function
export { searchConversations };
```
  </action>
  <verify>Build succeeds: `npm run build`</verify>
  <done>searchConversations function added to search.ts</done>
</task>

<task type="auto">
  <name>Task 2: Update search_memories to include conversations</name>
  <files>src/mcp-server/tools/memory.ts</files>
  <action>
Update memory.ts to search both embeddings and conversations:

1. Add import:
```typescript
import { searchConversations, type ConversationSearchResult } from '../../memory/search.js';
```

2. Add include_conversations parameter to tool:
```typescript
server.tool(
  'search_memories',
  'Search past conversations and memories semantically. Returns relevant results from both memory embeddings and conversation history.',
  {
    query: z.string().describe('Natural language search query (e.g., "discussions about project deadlines")'),
    limit: z.number().optional().default(5).describe('Max results to return (default: 5)'),
    days_back: z.number().optional().describe('Only search memories from last N days (omit for all time)'),
    include_conversations: z.boolean().optional().default(true).describe('Include conversation history in search (default: true)'),
  },
  async ({ query, limit, days_back, include_conversations }) => {
    try {
      log.info({ query, limit, days_back, include_conversations }, 'search_memories called');

      // Search embeddings
      const embeddingResults = await semanticSearch(query, {
        topK: limit,
        daysBack: days_back,
      });

      // Search conversations if enabled
      let conversationResults: ConversationSearchResult[] = [];
      if (include_conversations) {
        conversationResults = searchConversations(query, {
          topK: limit,
          daysBack: days_back,
        });
      }

      // Format embedding results
      const embeddingFormatted = embeddingResults.map((r, i) => {
        const date = new Date(r.timestamp).toLocaleDateString();
        const score = (r.score * 100).toFixed(0);
        return `[Memory ${i + 1}] (${score}% match, ${date})\n${r.text}`;
      });

      // Format conversation results
      const conversationFormatted = conversationResults.map((r, i) => {
        const date = new Date(r.endedAt).toLocaleDateString();
        const score = (r.score * 100).toFixed(0);
        return `[Conversation ${i + 1}] (${score}% match, ${date}, ${r.messageCount} msgs)\nSession: ${r.sessionId}\n${r.summary}`;
      });

      // Combine results
      const totalResults = embeddingResults.length + conversationResults.length;

      if (totalResults === 0) {
        return {
          content: [{
            type: 'text' as const,
            text: 'No relevant memories or conversations found for that query.',
          }],
        };
      }

      let output = '';
      if (embeddingFormatted.length > 0) {
        output += `=== Memory Embeddings (${embeddingFormatted.length}) ===\n\n${embeddingFormatted.join('\n\n')}\n\n`;
      }
      if (conversationFormatted.length > 0) {
        output += `=== Conversation History (${conversationFormatted.length}) ===\n\n${conversationFormatted.join('\n\n')}`;
        output += '\n\nTip: Use get_conversation with a session_id to retrieve full transcript.';
      }

      log.info({ embeddingCount: embeddingResults.length, conversationCount: conversationResults.length }, 'search_memories completed');

      return {
        content: [{
          type: 'text' as const,
          text: output.trim(),
        }],
      };
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      log.error({ error: msg }, 'search_memories failed');
      return {
        content: [{
          type: 'text' as const,
          text: `Error searching memories: ${msg}`,
        }],
      };
    }
  }
);
```
  </action>
  <verify>Build succeeds: `npm run build`</verify>
  <done>search_memories includes conversation results</done>
</task>

<task type="auto">
  <name>Task 3: Create get_conversation MCP tool</name>
  <files>src/mcp-server/tools/conversations.ts, src/mcp-server/index.ts</files>
  <action>
1. Create src/mcp-server/tools/conversations.ts:

```typescript
/**
 * Conversation MCP tools
 * Exposes get_conversation to retrieve full transcripts
 */

import { z } from 'zod';
import type { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { getConversationBySessionId, parseTranscript, extractConversationText } from '../../memory/conversations.js';
import { createMcpLogger } from '../../utils/index.js';

const log = createMcpLogger('mcp:conversations');

/**
 * Register conversation tools with MCP server
 */
export function registerConversationTools(server: McpServer): void {
  // get_conversation: Retrieve full transcript by session ID
  server.tool(
    'get_conversation',
    'Retrieve the full transcript of a past conversation by session ID. Use search_memories first to find relevant session IDs.',
    {
      session_id: z.string().describe('Session ID from search_memories results'),
    },
    async ({ session_id }) => {
      try {
        log.info({ session_id }, 'get_conversation called');

        const conversation = getConversationBySessionId(session_id);

        if (!conversation) {
          return {
            content: [{
              type: 'text' as const,
              text: `Conversation not found: ${session_id}`,
            }],
          };
        }

        // Parse and format transcript for readability
        const entries = parseTranscript(conversation.transcript);
        const formatted = extractConversationText(entries);

        const header = [
          `=== Conversation: ${session_id} ===`,
          `Started: ${new Date(conversation.startedAt).toLocaleString()}`,
          `Ended: ${new Date(conversation.endedAt).toLocaleString()}`,
          `Messages: ${conversation.messageCount}`,
          `Summary: ${conversation.summary}`,
          '',
          '=== Transcript ===',
          '',
        ].join('\n');

        log.info({ session_id, messageCount: conversation.messageCount }, 'get_conversation completed');

        return {
          content: [{
            type: 'text' as const,
            text: header + formatted,
          }],
        };
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        log.error({ error: msg, session_id }, 'get_conversation failed');
        return {
          content: [{
            type: 'text' as const,
            text: `Error retrieving conversation: ${msg}`,
          }],
        };
      }
    }
  );
}
```

2. Update src/mcp-server/index.ts to register:

Add import:
```typescript
import { registerConversationTools } from './tools/conversations.js';
```

Add registration after registerMemoryTools:
```typescript
// Register all tools
registerCronTools(server);
registerMemoryTools(server);
registerConversationTools(server);
```
  </action>
  <verify>Build succeeds: `npm run build`</verify>
  <done>get_conversation MCP tool created and registered</done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build`
2. MCP server lists all tools:
   ```bash
   echo '{"jsonrpc":"2.0","method":"tools/list","id":1}' | npx tsx src/index.ts mcp
   ```
   Should show: search_memories, create_cron, list_crons, delete_cron, get_conversation
3. Gateway starts: `npx tsx src/index.ts daemon` (Ctrl+C after startup)
</verification>

<success_criteria>
- search_memories returns both memory embeddings and conversation summaries
- Session IDs included in conversation search results
- get_conversation retrieves full transcript with formatted output
- Tools properly logged via mcp:conversations namespace
</success_criteria>

<output>
After completion, create `.planning/phases/07.2-conversation-continuity/07.2-04-SUMMARY.md`
</output>
