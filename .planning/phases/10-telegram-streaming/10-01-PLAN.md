---
phase: 10-telegram-streaming
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config/schema.ts
  - src/telegram/bot.ts
  - src/telegram/streaming.ts
  - src/telegram/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Streaming config exists with enabled and throttleMs options"
    - "Bot has throttler transformer configured"
    - "Streaming module can spawn Claude with stream-json output"
    - "Streaming module can parse NDJSON events and call onChunk callback with text"
    - "Streaming module extracts cost_usd from final result event"
  artifacts:
    - path: "src/telegram/streaming.ts"
      provides: "Claude stream spawner + draft streaming logic"
      exports: ["streamClaudeResponse", "StreamConfig"]
    - path: "src/config/schema.ts"
      provides: "Extended jsonConfigSchema with streaming options"
      contains: "streaming:"
    - path: "src/telegram/bot.ts"
      provides: "Bot with throttler transformer"
      contains: "apiThrottler"
  key_links:
    - from: "src/telegram/streaming.ts"
      to: "child_process.spawn"
      via: "streamClaudeResponse function"
      pattern: "spawn.*claude.*stream-json"
    - from: "src/telegram/bot.ts"
      to: "@grammyjs/transformer-throttler"
      via: "bot.api.config.use"
      pattern: "apiThrottler"
---

<objective>
Create streaming infrastructure for real-time Claude responses in Telegram.

Purpose: Users will see Claude's response building in real-time via draft messages, providing immediate feedback during generation.

Output:
- `streaming.ts` module with Claude CLI stream spawner
- Config schema extended with streaming options
- Bot configured with throttler transformer
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-telegram-streaming/10-RESEARCH.md

# Existing files to modify
@src/config/schema.ts
@src/telegram/bot.ts
@src/telegram/index.ts

# Reference for spawner patterns
@src/daemon/spawner.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install throttler and extend config schema</name>
  <files>package.json, src/config/schema.ts</files>
  <action>
1. Install dependency:
   ```bash
   npm install @grammyjs/transformer-throttler
   ```

2. Extend `jsonConfigSchema` in src/config/schema.ts to add streaming options:
   ```typescript
   export const jsonConfigSchema = z
     .object({
       model: z.string().optional(),
       streaming: z.object({
         enabled: z.boolean().default(true),
         throttleMs: z.number().min(100).max(2000).default(500),
       }).default({ enabled: true, throttleMs: 500 }),
     })
     .strict();
   ```

Keep existing `model` field. The streaming object has two options:
- `enabled`: Toggle streaming on/off (default: true)
- `throttleMs`: Minimum interval between draft updates (default: 500ms)
  </action>
  <verify>
- `npm ls @grammyjs/transformer-throttler` shows installed
- TypeScript compiles: `npm run build`
- Config schema exports JsonConfig type with streaming property
  </verify>
  <done>
- @grammyjs/transformer-throttler installed
- jsonConfigSchema includes streaming.enabled and streaming.throttleMs with defaults
  </done>
</task>

<task type="auto">
  <name>Task 2: Create streaming module with Claude CLI spawner</name>
  <files>src/telegram/streaming.ts</files>
  <action>
Create new file `src/telegram/streaming.ts` with:

1. **Imports:**
   ```typescript
   import { spawn } from "child_process";
   import { createInterface } from "readline";
   import { createChildLogger } from "../utils/index.js";
   import { KLAUSBOT_HOME, buildSystemPrompt } from "../memory/index.js";
   ```

2. **StreamConfig interface** matching config schema:
   ```typescript
   export interface StreamConfig {
     enabled: boolean;
     throttleMs: number;
   }
   ```

3. **StreamEvent interface** for NDJSON parsing:
   ```typescript
   interface StreamEvent {
     type: string;
     delta?: { text?: string };
     result?: string;        // Present in final "result" event
     cost_usd?: number;      // Present in final "result" event
     session_id?: string;    // Present in final "result" event
   }
   ```

4. **streamClaudeResponse function** using CALLBACK PATTERN (not generator):
   ```typescript
   export interface StreamOptions {
     model?: string;
     additionalInstructions?: string;
     signal?: AbortSignal;
   }

   export interface StreamResult {
     result: string;
     cost_usd: number;
   }

   /**
    * Stream Claude response with callback for each text chunk.
    * Uses callback pattern (not generator) so caller can access return value.
    *
    * @param prompt - User message
    * @param options - Model, additional instructions, abort signal
    * @param onChunk - Called with each text delta as it arrives
    * @returns Promise with final result and cost
    */
   export async function streamClaudeResponse(
     prompt: string,
     options: StreamOptions,
     onChunk: (text: string) => void,
   ): Promise<StreamResult> {
     const log = createChildLogger("streaming");

     // Build system prompt from identity files (same as spawner.ts)
     let systemPrompt = buildSystemPrompt();

     // Append additional instructions if provided
     if (options.additionalInstructions) {
       systemPrompt += "\n\n" + options.additionalInstructions;
     }

     // Wrap prompt in XML tags for security (same as spawner.ts)
     const wrappedPrompt = `<user_message>\n${prompt}\n</user_message>`;

     // Build args - note: no --mcp-config or --settings for streaming
     // (hooks don't make sense for streaming, MCP tools work differently)
     const args = [
       "--dangerously-skip-permissions",
       "-p", wrappedPrompt,
       "--output-format", "stream-json",
       "--include-partial-messages",
       "--append-system-prompt", systemPrompt,
     ];

     if (options.model) {
       args.push("--model", options.model);
     }

     return new Promise((resolve, reject) => {
       // CRITICAL: stdin must inherit to avoid hang bug (same as spawner.ts)
       const claude = spawn("claude", args, {
         stdio: ["inherit", "pipe", "pipe"],
         cwd: KLAUSBOT_HOME,
         env: process.env,
       });

       let accumulated = "";
       let costUsd = 0;
       let sessionId = "";

       // Handle abort signal
       if (options.signal) {
         options.signal.addEventListener("abort", () => {
           claude.kill("SIGTERM");
         });
       }

       const rl = createInterface({ input: claude.stdout });

       rl.on("line", (line) => {
         try {
           const event: StreamEvent = JSON.parse(line);

           // Text delta events - call onChunk callback
           if (event.type === "content_block_delta" && event.delta?.text) {
             accumulated += event.delta.text;
             onChunk(event.delta.text);
           }

           // Final "result" event contains metadata
           // Event type is "result" and has result, cost_usd, session_id fields
           if (event.type === "result") {
             if (event.result !== undefined) {
               accumulated = event.result;  // Use final result (may differ from accumulated deltas)
             }
             if (event.cost_usd !== undefined) {
               costUsd = event.cost_usd;
             }
             if (event.session_id !== undefined) {
               sessionId = event.session_id;
             }
           }
         } catch {
           // Skip non-JSON lines (stderr leakage, etc.)
         }
       });

       rl.on("close", () => {
         log.info({
           resultLength: accumulated.length,
           cost_usd: costUsd,
           session_id: sessionId
         }, "Stream completed");
         resolve({ result: accumulated, cost_usd: costUsd });
       });

       claude.on("error", (err) => {
         log.error({ err }, "Stream spawn error");
         reject(err);
       });

       claude.stderr.on("data", (data: Buffer) => {
         log.warn({ stderr: data.toString().slice(0, 200) }, "Stream stderr");
       });
     });
   }
   ```

Key implementation notes:
- **Callback pattern**: `onChunk` is called for each text delta, return value is Promise<StreamResult>
- **systemPrompt**: Built from `buildSystemPrompt()` imported from memory module
- **additionalInstructions**: Appended to systemPrompt with newline separator
- **cost_usd extraction**: From final NDJSON event with `type === "result"`
- **No hooks/MCP**: Streaming mode skips hooks (SessionStart/End don't apply to streams)
- **stdio inherit**: Uses `['inherit', 'pipe', 'pipe']` to avoid hang bug (issue #771)
  </action>
  <verify>
- `npm run build` compiles without errors
- File exists at src/telegram/streaming.ts
- Exports StreamConfig, StreamOptions, StreamResult, and streamClaudeResponse
  </verify>
  <done>
- streaming.ts created with callback-based streamClaudeResponse
- Function calls onChunk(text) for each delta, returns Promise<{result, cost_usd}>
- cost_usd extracted from final "result" event in NDJSON stream
- systemPrompt built from buildSystemPrompt(), additionalInstructions appended
  </done>
</task>

<task type="auto">
  <name>Task 3: Add throttler to bot and export streaming module</name>
  <files>src/telegram/bot.ts, src/telegram/index.ts</files>
  <action>
1. In `src/telegram/bot.ts`, add apiThrottler after autoRetry:
   ```typescript
   import { apiThrottler } from "@grammyjs/transformer-throttler";

   // After autoRetry config
   bot.api.config.use(
     apiThrottler({
       out: {
         maxConcurrent: 1,
         minTime: 100, // Allow faster for drafts, let Telegram reject if needed
       },
     }),
   );
   ```

   Place the throttler AFTER autoRetry so retries happen on rate-limited requests.

2. In `src/telegram/index.ts`, add export:
   ```typescript
   export {
     streamClaudeResponse,
     type StreamConfig,
     type StreamOptions,
     type StreamResult
   } from "./streaming.js";
   ```
  </action>
  <verify>
- `npm run build` compiles
- Bot startup still works (no runtime errors)
  </verify>
  <done>
- Bot has apiThrottler transformer configured
- streaming module exported from telegram/index.ts
  </done>
</task>

</tasks>

<verification>
1. Build passes: `npm run build`
2. Dependencies installed: `npm ls @grammyjs/transformer-throttler`
3. Config schema valid: Import and inspect JsonConfig type
4. Streaming module compiles and exports correctly
</verification>

<success_criteria>
- Streaming infrastructure in place (module, config, throttler)
- Claude CLI stream spawner implemented with callback pattern
- Config allows enabling/disabling streaming and setting throttle interval
- Ready for gateway integration in Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/10-telegram-streaming/10-01-SUMMARY.md`
</output>
