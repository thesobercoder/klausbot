---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/telegram/bot.ts
  - src/telegram/handlers.ts
  - src/telegram/commands.ts
  - src/telegram/index.ts
  - src/utils/split.ts
autonomous: true

must_haves:
  truths:
    - "Bot connects to Telegram API without errors"
    - "Bot receives messages and logs them"
    - "Bot sends typing indicator while processing"
    - "Long messages are split at 4096 char limit"
    - "Bot handles /start command"
  artifacts:
    - path: "src/telegram/bot.ts"
      provides: "grammY bot with plugins configured"
      exports: ["bot", "MyContext"]
    - path: "src/telegram/handlers.ts"
      provides: "Message routing middleware"
      exports: ["setupHandlers"]
    - path: "src/telegram/commands.ts"
      provides: "Telegram command handlers"
      exports: ["setupCommands"]
    - path: "src/utils/split.ts"
      provides: "Message splitting utility"
      exports: ["splitMessage", "sendLongMessage"]
  key_links:
    - from: "src/telegram/bot.ts"
      to: "grammy"
      via: "Bot constructor"
      pattern: "new Bot"
    - from: "src/telegram/bot.ts"
      to: "@grammyjs/auto-chat-action"
      via: "middleware"
      pattern: "autoChatAction"
---

<objective>
Create Telegram bot core with grammY, plugins for rate limiting and typing indicators, and message handling infrastructure.

Purpose: Establish Telegram connectivity - the communication channel for klausbot.
Output: Working bot that connects, receives messages, shows typing, handles commands.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create grammY bot with plugins</name>
  <files>src/telegram/bot.ts</files>
  <action>
Create src/telegram/bot.ts following RESEARCH.md Pattern 2:

- Import Bot, Context, GrammyError, HttpError from grammy
- Import run, sequentialize from @grammyjs/runner
- Import autoRetry from @grammyjs/auto-retry
- Import autoChatAction, AutoChatActionFlavor from @grammyjs/auto-chat-action
- Import config from ../config
- Import logger, createChildLogger from ../utils

Define MyContext type: Context & AutoChatActionFlavor

Create and export bot instance:

- new Bot<MyContext>(config.TELEGRAM_BOT_TOKEN)

Configure bot.api.config.use(autoRetry()):

- maxRetryAttempts: 3
- maxDelaySeconds: 300

Add middleware in order:

1. autoChatAction() - typing indicator
2. sequentialize((ctx) => ctx.chat?.id.toString()) - preserve message order per chat

Add error handler (bot.catch):

- Log GrammyError with error_code, description
- Log HttpError with error details
- Log unknown errors
- Send user-friendly error message to chat (non-blocking, wrap in try/catch)

Export createRunner() function that:

- Returns run(bot) handle
- Sets up SIGINT/SIGTERM handlers to call handle.stop()

Do NOT start the bot in this file - that happens in gateway.
</action>
<verify>npm run build succeeds; bot.ts exports bot, MyContext, createRunner</verify>
<done>Bot configured with all plugins, error handling, graceful shutdown support</done>
</task>

<task type="auto">
  <name>Task 2: Create message splitting and sending utilities</name>
  <files>src/utils/split.ts, src/utils/index.ts</files>
  <action>
Create src/utils/split.ts following RESEARCH.md Pattern 5:

- Define MAX_LENGTH = 4096 (Telegram limit)
- Export splitMessage(text: string): string[]
  - If text <= MAX_LENGTH, return [text]
  - Split at sentence boundary (". ") preferring near end
  - Fallback to word boundary (" ")
  - Hard split if no boundary found
  - Trim chunks, filter empty

- Export async sendLongMessage(ctx: MyContext, text: string): Promise<void>
  - Split message using splitMessage()
  - Send each chunk with ctx.reply()
  - Small delay between chunks (100ms) to maintain order

Update src/utils/index.ts:

- Re-export from split.ts
  </action>
  <verify>Unit test: splitMessage with 5000 char string returns 2 chunks, each <= 4096</verify>
  <done>Messages auto-split at sentence/word boundaries, sendLongMessage handles chunking</done>
  </task>

<task type="auto">
  <name>Task 3: Create command and message handlers</name>
  <files>src/telegram/commands.ts, src/telegram/handlers.ts, src/telegram/index.ts</files>
  <action>
Create src/telegram/commands.ts:
- Import bot, MyContext from ./bot
- Import logger from ../utils

Export setupCommands():

- bot.command('start', handler) - placeholder that logs and replies "Pairing flow coming soon. Chat ID: {ctx.chat.id}"
- bot.command('model', handler) - placeholder that replies "Model switching coming in Phase 2"
- Log each command invocation

Create src/telegram/handlers.ts:

- Import bot, MyContext from ./bot
- Import logger, sendLongMessage from ../utils

Export setupHandlers():

- bot.on('message:text', handler):
  - Log incoming message (chat.id, from.username, text preview)
  - For now: echo back "Received: {first 50 chars}..." (placeholder for Claude integration)
  - Use sendLongMessage for response

- bot.on('message', handler) as catch-all for non-text:
  - Reply "I only understand text messages for now."

Create src/telegram/index.ts:

- Re-export bot, MyContext, createRunner from ./bot
- Re-export setupCommands from ./commands
- Re-export setupHandlers from ./handlers

Note: Actual Claude spawning comes in Plan 04. This is just the Telegram layer.
</action>
<verify>Build succeeds; manual test: send message to bot, verify echo response and typing indicator</verify>
<done>Commands (/start, /model) registered, message handler echoes, all logged</done>
</task>

</tasks>

<verification>
After all tasks:
1. `npm run build` succeeds
2. Create temporary test script (src/test-bot.ts):
   ```typescript
   import { bot, setupCommands, setupHandlers, createRunner } from './telegram/index.js';
   setupCommands();
   setupHandlers();
   const runner = createRunner();
   console.log('Bot running... Press Ctrl+C to stop');
   ```
3. Run with valid TELEGRAM_BOT_TOKEN in .env
4. Send message to bot - verify:
   - Typing indicator appears
   - Echo response received
   - /start shows chat ID
   - Logs show structured JSON
5. Ctrl+C gracefully stops
</verification>

<success_criteria>

- Bot connects to Telegram successfully
- Typing indicator (auto-chat-action) works during processing
- Messages echoed back (placeholder for Claude)
- /start command works (placeholder for pairing)
- Long messages (>4096) split correctly
- Graceful shutdown on SIGINT/SIGTERM
- All actions logged with pino
  </success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
