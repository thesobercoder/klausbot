---
phase: 14-testing-framework
plan: 05
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - tests/integration/message-flow.test.ts
  - tests/integration/cron-flow.test.ts
autonomous: true

must_haves:
  truths:
    - "Message flow: user text queued -> spawner called with correct prompt -> response formatted and sent via bot API"
    - "Message flow: media attachments processed before spawner invocation"
    - "Cron flow: executor calls spawner with cron instructions -> result sent to chat -> retry on failure"
    - "Error handling: spawner failure results in error message sent to chat and queue marked failed"
    - "All external boundaries mocked: child_process.spawn never called, Telegram API never called"
  artifacts:
    - path: "tests/integration/message-flow.test.ts"
      provides: "Integration test for message queuing through response delivery"
      min_lines: 80
    - path: "tests/integration/cron-flow.test.ts"
      provides: "Integration test for cron execution through notification delivery"
      min_lines: 60
  key_links:
    - from: "tests/integration/message-flow.test.ts"
      to: "src/daemon/queue.ts"
      via: "MessageQueue add/take lifecycle"
      pattern: "import.*MessageQueue"
    - from: "tests/integration/message-flow.test.ts"
      to: "src/daemon/spawner.ts"
      via: "mocked queryClaudeCode"
      pattern: "vi\\.mock.*spawner"
    - from: "tests/integration/cron-flow.test.ts"
      to: "src/cron/executor.ts"
      via: "executeCronJob with mocked spawner and bot"
      pattern: "import.*executeCronJob"
---

<objective>
Integration tests that exercise multi-module flows end-to-end with mocked external boundaries (Claude CLI, Telegram API). Covers the two critical runtime paths: message handling and cron execution.

Purpose: TEST-02 requirement. "E2E tests cover critical flows." These tests verify that modules wire together correctly — queue feeds spawner, spawner result reaches bot API, errors propagate properly. Unit tests verify modules in isolation; these verify the seams.
Output: 2 integration test files covering message flow and cron flow.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-testing-framework/14-RESEARCH.md
@src/daemon/gateway.ts
@src/daemon/spawner.ts
@src/daemon/queue.ts
@src/cron/executor.ts
@src/heartbeat/executor.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Message flow integration test</name>
  <files>tests/integration/message-flow.test.ts</files>
  <action>
Create `tests/integration/message-flow.test.ts` that tests the message handling pipeline: queue -> spawner -> response -> bot API send.

**Strategy:** Test the flow by using real MessageQueue (with temp dir) and mocking only external boundaries (spawner, bot API, config, etc.). This verifies the internal wiring works without calling Claude CLI or Telegram.

**Mocking setup:**
```typescript
// Mock logger everywhere
vi.mock("../../src/utils/logger.js", () => ({
  createChildLogger: () => ({
    info: vi.fn(), debug: vi.fn(), warn: vi.fn(), error: vi.fn(),
  }),
}));

// Mock spawner — the external boundary
const mockQueryClaudeCode = vi.fn();
vi.mock("../../src/daemon/spawner.js", () => ({
  queryClaudeCode: mockQueryClaudeCode,
  writeMcpConfigFile: vi.fn().mockReturnValue("/tmp/mock.json"),
  getMcpConfig: vi.fn().mockReturnValue({ mcpServers: {} }),
  getHooksConfig: vi.fn().mockReturnValue({ hooks: {} }),
}));

// Mock bot API — the other external boundary
const mockSendMessage = vi.fn().mockResolvedValue({ message_id: 1 });
const mockSendChatAction = vi.fn().mockResolvedValue(true);
vi.mock("../../src/telegram/bot.js", () => ({
  bot: {
    api: {
      sendMessage: mockSendMessage,
      sendChatAction: mockSendChatAction,
    },
  },
}));
```

Also mock: config, memory, pairing, bootstrap, platform, heartbeat, cron, media, utils — same pattern as gateway unit test but reuse the real MessageQueue with a temp directory.

**Test cases:**

**Happy path — text message:**
1. Create real MessageQueue with temp dir
2. Add message: `queue.add(12345, "Hello Claude")`
3. Take message: `msg = queue.take()`
4. Assert msg has correct chatId, text, status "processing"
5. Call `mockQueryClaudeCode` with the message text
6. Configure mock to return `{ result: "Hello human!", cost_usd: 0.01, session_id: "s1", duration_ms: 500, is_error: false }`
7. Verify mock was called with prompt containing "Hello Claude"
8. Simulate sending response: call `mockSendMessage(12345, expectedHtml)`
9. Verify sendMessage was called with chatId 12345
10. Complete queue: `queue.complete(msg.id)`
11. Assert queue stats show 0 pending, 0 processing

**Error path — spawner failure:**
1. Add message to queue
2. Take message
3. Configure mockQueryClaudeCode to reject with `new Error("Claude timed out after 90s")`
4. Verify error propagation: the error message string contains "timed out"
5. Fail queue: `queue.fail(msg.id, "timed out")`
6. Assert queue stats show 1 failed

**Threading context preserved:**
1. Add message with threading: `queue.add(12345, "Reply", undefined, { messageThreadId: 42, replyToMessageId: 100 })`
2. Take and verify threading context intact
3. Verify that when sendMessage is called, reply_parameters includes message_id: 100

**Queue ordering (FIFO):**
1. Add 3 messages: "first", "second", "third"
2. take() returns "first", then "second", then "third"
3. Complete all, verify stats clean

Use `beforeEach`/`afterEach` for temp dir setup/teardown and mock reset.
  </action>
  <verify>`npx vitest run tests/integration/message-flow.test.ts --reporter=verbose` — all tests pass</verify>
  <done>Message flow integration verified: queue -> spawner -> response -> bot API path works. Error propagation tested. Threading preserved. FIFO ordering confirmed.</done>
</task>

<task type="auto">
  <name>Task 2: Cron execution flow integration test</name>
  <files>tests/integration/cron-flow.test.ts</files>
  <action>
Create `tests/integration/cron-flow.test.ts` that tests the cron execution pipeline: executor calls spawner -> result sent to chat -> retry on failure.

**Strategy:** Import `executeCronJob` from `../../src/cron/executor.js` with mocked spawner and bot. This exercises the real executor logic (retry, notification, error handling) with controlled external boundaries.

**Mocking setup:**
```typescript
vi.mock("../../src/utils/logger.js", () => ({
  createChildLogger: () => ({
    info: vi.fn(), debug: vi.fn(), warn: vi.fn(), error: vi.fn(),
  }),
}));
vi.mock("../../src/utils/index.js", () => ({
  createChildLogger: () => ({
    info: vi.fn(), debug: vi.fn(), warn: vi.fn(), error: vi.fn(),
  }),
}));

const mockQueryClaudeCode = vi.fn();
vi.mock("../../src/daemon/spawner.js", () => ({
  queryClaudeCode: mockQueryClaudeCode,
}));

const mockSendMessage = vi.fn().mockResolvedValue({ message_id: 1 });
vi.mock("../../src/telegram/bot.js", () => ({
  bot: { api: { sendMessage: mockSendMessage } },
}));

vi.mock("../../src/config/index.js", () => ({
  getJsonConfig: vi.fn().mockReturnValue({ model: "claude-opus-4-6" }),
}));
```

**Test fixture:** Create a test CronJob object using `createCronJob` from helpers:
```typescript
const testJob = createCronJob({
  id: "cron-test-1",
  name: "Daily Report",
  instruction: "Generate daily summary",
  chatId: 12345,
});
```

**Test cases:**

**Happy path — successful execution:**
1. Configure mockQueryClaudeCode to resolve with `{ result: "Report done", cost_usd: 0.02, session_id: "c1", duration_ms: 1000, is_error: false }`
2. Call `await executeCronJob(testJob)`
3. Assert result: `{ success: true, result: "Report done", durationMs: expect.any(Number) }`
4. Assert mockQueryClaudeCode called once with:
   - First arg: "Generate daily summary" (the instruction)
   - Second arg options containing `timeout: 3600000` (CRON_TIMEOUT) and `chatId: 12345`
5. Assert mockSendMessage called with chatId 12345 and message containing "[Cron: Daily Report]" and "Report done"

**Retry path — first attempt fails, retry succeeds:**
1. Configure mockQueryClaudeCode to:
   - First call: reject with `new Error("temporary failure")`
   - Second call: resolve with `{ result: "Retry worked", ... }`
2. Call `await executeCronJob(testJob)` (will take >1s due to RETRY_DELAY, but we can mock setTimeout or use fake timers)
3. Assert result: `{ success: true, result: "Retry worked", ... }`
4. Assert mockQueryClaudeCode called twice
5. Assert mockSendMessage called once with success message (not failure)

**Note on RETRY_DELAY:** The executor uses `await new Promise(r => setTimeout(r, 60000))` for retry delay. Use `vi.useFakeTimers()` and `vi.advanceTimersByTimeAsync(60000)` to avoid waiting 60 real seconds. Call `vi.useRealTimers()` in afterEach.

**Both attempts fail:**
1. Configure mockQueryClaudeCode to reject both times
2. Call `await executeCronJob(testJob)` with fake timers
3. Assert result: `{ success: false, result: expect.stringContaining("failure"), ... }`
4. Assert mockSendMessage called with message containing "[Cron: Daily Report FAILED]"

**Spawner receives correct additional instructions:**
1. Execute job and inspect mockQueryClaudeCode call
2. Assert second arg has `additionalInstructions` containing `<cron-execution>` XML tag
3. Assert additional instructions contain job.name and job.id

Use `beforeEach` for mock reset and fake timer setup.
  </action>
  <verify>`npx vitest run tests/integration/cron-flow.test.ts --reporter=verbose` — all tests pass</verify>
  <done>Cron flow integration verified: executor -> spawner -> bot notification path works. Retry logic tested (success on retry, failure after retry). Correct timeout and additional instructions passed to spawner.</done>
</task>

</tasks>

<verification>
- `npm test` passes all integration tests alongside unit tests
- No real child_process.spawn calls (Claude CLI not invoked)
- No real Telegram API calls (bot.api.sendMessage is mocked)
- Integration tests verify multi-module wiring, not just isolated functions
</verification>

<success_criteria>
1. Message flow: queue add -> take -> spawner call -> bot send -> complete cycle tested
2. Message flow: error propagation, threading, FIFO ordering tested
3. Cron flow: execute -> notify success, retry on failure, notify failure tested
4. Cron flow: correct timeout, model, chatId, additional instructions passed
5. All external boundaries mocked — tests run without Claude CLI or Telegram
6. All tests pass on `npm test`
</success_criteria>

<output>
After completion, create `.planning/phases/14-testing-framework/14-05-SUMMARY.md`
</output>
