# Phase 7.2: Conversation Continuity - Research

**Researched:** 2026-01-31
**Domain:** Claude Code hooks, conversation storage, Drizzle ORM, SQLite schema management
**Confidence:** HIGH

## Summary

Phase 7.2 replaces the current markdown conversation logger with SQLite-backed conversation storage, using Claude Code hooks for context injection and transcript capture. The phase introduces three hook types (SessionStart, PreCompact, SessionEnd) that klausbot handles via CLI subcommands.

**Key insight:** Claude Code hooks receive JSON via stdin with `transcript_path` pointing to the active JSONL transcript. SessionEnd hook parses this transcript, stores it in SQLite, generates a summary, and creates embeddings. SessionStart hook injects datetime + recent conversation summaries into context.

**Primary recommendation:** Implement `klausbot hook start|compact|end` CLI commands, use Drizzle ORM for SQLite schema management with runtime migrations on gateway startup, extend existing `search_memories` MCP tool to search conversation summaries.

## Current State Analysis

### Existing Conversation Logger (`src/memory/logger.ts`)

| Function                   | Purpose                                                        | After Phase 7.2 |
| -------------------------- | -------------------------------------------------------------- | --------------- |
| `logUserMessage()`         | Appends to `conversations/{date}.md`                           | REMOVE          |
| `logAssistantMessage()`    | Appends to `conversations/{date}.md`, calls `storeEmbedding()` | REMOVE          |
| `ensureConversationFile()` | Creates daily markdown files                                   | REMOVE          |

**Current flow:**

1. Gateway receives message
2. `logUserMessage()` appends to markdown
3. Claude responds
4. `logAssistantMessage()` appends + embeds response

**New flow (after 7.2):**

1. Gateway spawns Claude with hooks configured via `--settings`
2. SessionStart hook injects context (datetime, recent summaries)
3. Claude processes, writes to Claude's internal transcript
4. SessionEnd hook parses transcript, stores to SQLite, summarizes

### Existing Database Schema (`src/memory/db.ts`)

Current tables (better-sqlite3 + sqlite-vec):

```sql
CREATE TABLE embeddings (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  text_id TEXT UNIQUE NOT NULL,
  text TEXT NOT NULL,
  timestamp TEXT NOT NULL,
  source TEXT NOT NULL
);

CREATE VIRTUAL TABLE vec_embeddings USING vec0(
  embedding float[1536]
);
```

**Gap:** No `conversations` table, no Drizzle ORM, raw SQL schema management.

### Existing Spawner (`src/daemon/spawner.ts`)

```typescript
const args = [
  "--dangerously-skip-permissions",
  "-p",
  prompt,
  "--output-format",
  "json",
  "--append-system-prompt",
  systemPrompt,
  "--mcp-config",
  mcpConfigPath,
];
```

**Missing:** `--settings` flag for hooks configuration.

## Standard Stack

### Core

| Library        | Version | Purpose               | Why Standard                               |
| -------------- | ------- | --------------------- | ------------------------------------------ |
| drizzle-orm    | ^0.39.x | ORM for SQLite        | Type-safe, lightweight, runtime migrations |
| drizzle-kit    | ^0.30.x | Schema migrations CLI | Generates SQL, push/generate workflows     |
| better-sqlite3 | ^12.6.2 | SQLite driver         | Already installed, fastest Node.js driver  |
| sqlite-vec     | ^0.1.7  | Vector search         | Already installed for embeddings           |

### Supporting (Already Installed)

| Library   | Version | Purpose                      |
| --------- | ------- | ---------------------------- |
| openai    | ^6.17.0 | Summarization via Claude/GPT |
| zod       | ^4.3.6  | Schema validation            |
| commander | ^14.0.2 | CLI commands                 |

**Installation:**

```bash
npm install drizzle-orm
npm install --save-dev drizzle-kit
```

## Architecture Patterns

### Recommended File Structure

```
src/
  memory/
    db.ts                  # UPDATE: Drizzle db instance
    schema.ts              # NEW: Drizzle schema definitions
    migrate.ts             # UPDATE: Drizzle runtime migrations
    logger.ts              # REMOVE (replaced by hooks)
    conversations.ts       # NEW: Conversation CRUD operations
  cli/
    hook.ts                # NEW: klausbot hook start|compact|end
  daemon/
    spawner.ts             # UPDATE: Add --settings with hooks
drizzle/
  migrations/              # Generated migration files
drizzle.config.ts          # Drizzle configuration
```

### Pattern 1: Drizzle Schema Definition

```typescript
// src/memory/schema.ts
import { sqliteTable, text, integer, blob } from "drizzle-orm/sqlite-core";

export const embeddings = sqliteTable("embeddings", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  textId: text("text_id").unique().notNull(),
  text: text("text").notNull(),
  timestamp: text("timestamp").notNull(),
  source: text("source").notNull(),
});

export const conversations = sqliteTable("conversations", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  sessionId: text("session_id").unique().notNull(),
  startedAt: text("started_at").notNull(),
  endedAt: text("ended_at").notNull(),
  transcript: text("transcript").notNull(), // Full JSONL content
  summary: text("summary").notNull(), // LLM-generated summary
  messageCount: integer("message_count").notNull(),
  chatId: integer("chat_id"), // Telegram chat ID
});

export const conversationEmbeddings = sqliteTable("conversation_embeddings", {
  id: integer("id").primaryKey({ autoIncrement: true }),
  conversationId: integer("conversation_id")
    .notNull()
    .references(() => conversations.id),
  chunkIndex: integer("chunk_index").notNull(),
  text: text("text").notNull(),
  timestamp: text("timestamp").notNull(),
});
```

### Pattern 2: Runtime Migration

```typescript
// src/memory/migrate.ts
import { drizzle } from "drizzle-orm/better-sqlite3";
import { migrate } from "drizzle-orm/better-sqlite3/migrator";
import Database from "better-sqlite3";
import { getHomePath } from "./home.js";

export function runMigrations(): void {
  const dbPath = getHomePath("klausbot.db");
  const sqlite = new Database(dbPath);
  const db = drizzle(sqlite);

  // Run migrations from bundled folder
  migrate(db, { migrationsFolder: "./drizzle/migrations" });

  sqlite.close();
}
```

### Pattern 3: Hook CLI Command

```typescript
// src/cli/hook.ts
import { stdin } from 'process';

interface HookInput {
  session_id: string;
  transcript_path: string;
  cwd: string;
  hook_event_name: string;
  source?: string;  // SessionStart: 'startup' | 'resume' | 'clear' | 'compact'
  reason?: string;  // SessionEnd: exit reason
}

async function readStdin(): Promise<HookInput> {
  const chunks: Buffer[] = [];
  for await (const chunk of stdin) {
    chunks.push(chunk);
  }
  return JSON.parse(Buffer.concat(chunks).toString('utf-8'));
}

export async function handleHookStart(): Promise<void> {
  const input = await readStdin();

  // Generate context injection
  const datetime = new Date().toISOString();
  const recentSummaries = await getRecentConversationSummaries(3);

  const context = `<session-context>
Current datetime: ${datetime}

Recent conversation summaries:
${recentSummaries.map(s => `- ${s.startedAt}: ${s.summary}`).join('\n')}
</session-context>`;

  // Print to stdout - Claude Code adds to context
  console.log(context);
}

export async function handleHookEnd(): Promise<void> {
  const input = await readStdin();

  // Parse transcript, store conversation, generate summary
  const transcript = parseTranscript(input.transcript_path);
  const summary = await generateSummary(transcript);
  await storeConversation({
    sessionId: input.session_id,
    transcript: JSON.stringify(transcript),
    summary,
    ...
  });
}
```

### Pattern 4: Spawner Settings Configuration

```typescript
// src/daemon/spawner.ts
function getHooksConfig(): object {
  // Get exact path to klausbot CLI (not relying on global install)
  const klausbotPath = process.argv[1]; // e.g., /path/to/dist/index.js
  const nodeExecutable = process.argv[0];

  return {
    hooks: {
      SessionStart: [
        {
          matcher: "startup|resume",
          hooks: [
            {
              type: "command",
              command: `${nodeExecutable} "${klausbotPath}" hook start`,
              timeout: 10,
            },
          ],
        },
      ],
      PreCompact: [
        {
          hooks: [
            {
              type: "command",
              command: `${nodeExecutable} "${klausbotPath}" hook compact`,
              timeout: 30,
            },
          ],
        },
      ],
      SessionEnd: [
        {
          hooks: [
            {
              type: "command",
              command: `${nodeExecutable} "${klausbotPath}" hook end`,
              timeout: 60,
            },
          ],
        },
      ],
    },
  };
}

// In queryClaudeCode():
const settingsJson = JSON.stringify(getHooksConfig());
const args = [
  "--dangerously-skip-permissions",
  "-p",
  prompt,
  "--output-format",
  "json",
  "--append-system-prompt",
  systemPrompt,
  "--mcp-config",
  mcpConfigPath,
  "--settings",
  settingsJson, // NEW: inline hooks config
];
```

### Pattern 5: Transcript Parsing

```typescript
// Based on src/daemon/transcript.ts structure
interface TranscriptEntry {
  type: "user" | "assistant" | "summary" | "system";
  uuid?: string;
  sessionId?: string;
  timestamp?: string;
  message?: {
    role: string;
    content: Array<{ type: string; text?: string }>;
  };
}

function parseTranscript(transcriptPath: string): TranscriptEntry[] {
  const content = readFileSync(transcriptPath, "utf-8");
  const lines = content.split("\n").filter((line) => line.trim());

  return lines
    .map((line) => {
      try {
        return JSON.parse(line) as TranscriptEntry;
      } catch {
        return null;
      }
    })
    .filter(Boolean) as TranscriptEntry[];
}
```

## Don't Hand-Roll

| Problem             | Don't Build                 | Use Instead                    | Why                                             |
| ------------------- | --------------------------- | ------------------------------ | ----------------------------------------------- |
| Schema migrations   | Custom SQL version table    | Drizzle migrate()              | Handles version tracking, rollback, type safety |
| Transcript parsing  | Custom JSONL parser         | Existing transcript.ts pattern | Already tested, handles malformed lines         |
| Summary generation  | Rule-based extraction       | OpenAI API                     | Natural language understanding required         |
| Context window mgmt | Token counting + truncation | PreCompact hook                | Claude Code handles compaction internally       |

**Key insight:** Claude Code already manages the conversation lifecycle. We just need to hook into its events.

## Common Pitfalls

### Pitfall 1: Hook Command Path Resolution

**What goes wrong:** Hook command fails with "command not found"
**Why it happens:** Hook executes in different working directory, global klausbot not installed
**How to avoid:** Use absolute paths: `process.argv[0]` + `process.argv[1]`
**Warning signs:** Hooks silently fail, no conversation storage

### Pitfall 2: stdin Blocking

**What goes wrong:** Hook hangs indefinitely
**Why it happens:** Attempting to read stdin when it's not provided
**How to avoid:** Check if stdin is TTY, use timeout
**Warning signs:** Hook processes pile up, never complete

### Pitfall 3: Drizzle Migration Path in Production

**What goes wrong:** Migrations folder not found after build
**Why it happens:** Drizzle expects migrations at runtime, tsup doesn't copy them
**How to avoid:** Bundle migrations with dist, or use drizzle-kit push for simple schemas
**Warning signs:** "No migrations to run" with empty database

### Pitfall 4: SessionEnd Race with Process Exit

**What goes wrong:** Summarization incomplete, database not written
**Why it happens:** Claude CLI exits before async operations complete
**How to avoid:** Use sync database operations (better-sqlite3 is sync), avoid async summarization in SessionEnd
**Warning signs:** Truncated summaries, missing conversations

### Pitfall 5: Large Transcript Memory

**What goes wrong:** OOM when parsing long transcripts
**Why it happens:** Loading entire JSONL into memory
**How to avoid:** Stream parsing for transcripts > 10MB
**Warning signs:** Process crash on long sessions

## Claude Code Hooks Reference

### Hook Lifecycle

```
SessionStart → [UserPromptSubmit → PreToolUse → PostToolUse]* → PreCompact? → SessionEnd
```

### SessionStart Hook

**Input (stdin):**

```json
{
  "session_id": "abc123",
  "transcript_path": "~/.claude/projects/.../session.jsonl",
  "cwd": "/path/to/project",
  "hook_event_name": "SessionStart",
  "source": "startup", // startup | resume | clear | compact
  "model": "claude-sonnet-4-5-20250929"
}
```

**Output:** stdout text is added to Claude's context.

**Special capability:** Can write to `$CLAUDE_ENV_FILE` to persist environment variables.

### PreCompact Hook

**Input (stdin):**

```json
{
  "session_id": "abc123",
  "transcript_path": "~/.claude/projects/.../session.jsonl",
  "cwd": "/path/to/project",
  "hook_event_name": "PreCompact",
  "trigger": "manual", // manual | auto
  "custom_instructions": ""
}
```

**Purpose:** Save conversation state before context window compaction.

### SessionEnd Hook

**Input (stdin):**

```json
{
  "session_id": "abc123",
  "transcript_path": "~/.claude/projects/.../session.jsonl",
  "cwd": "/path/to/project",
  "hook_event_name": "SessionEnd",
  "reason": "other" // clear | logout | prompt_input_exit | bypass_permissions_disabled | other
}
```

**Behavior:** Cannot block session termination. Runs cleanup/logging.

### Hook Configuration via --settings

```bash
claude --settings '{"hooks": {...}}'
```

Hooks defined via `--settings` merge with file-based settings. Direct JSON inline works.

## Drizzle ORM Patterns

### Configuration File

```typescript
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "sqlite",
  schema: "./src/memory/schema.ts",
  out: "./drizzle/migrations",
  dbCredentials: {
    url: "file:" + process.env.HOME + "/.klausbot/klausbot.db",
  },
});
```

### Generate Migrations

```bash
npx drizzle-kit generate  # Creates migration files
npx drizzle-kit migrate   # Applies migrations
npx drizzle-kit push      # Direct schema sync (no migration files)
```

### Runtime Migration (Recommended for klausbot)

```typescript
import { migrate } from "drizzle-orm/better-sqlite3/migrator";

// In gateway startup, before bot starts
const db = drizzle(sqlite);
migrate(db, { migrationsFolder: "./drizzle/migrations" });
```

**Note:** Migration files must be bundled with dist. Add to tsup config:

```typescript
// tsup.config.ts
export default defineConfig({
  // ...
  publicDir: "drizzle/migrations",
});
```

Or use `drizzle-kit push` for simpler deployments (applies schema directly).

## MCP Tool Updates

### Extended search_memories

```typescript
server.tool(
  "search_memories",
  "Search past conversations semantically. Searches both memory embeddings AND conversation summaries.",
  {
    query: z.string().describe("Natural language search query"),
    limit: z.number().optional().default(5),
    days_back: z.number().optional(),
    include_conversations: z.boolean().optional().default(true),
  },
  async ({ query, limit, days_back, include_conversations }) => {
    const embeddingResults = await semanticSearch(query, {
      topK: limit,
      daysBack: days_back,
    });

    if (include_conversations) {
      const conversationResults = await searchConversations(query, {
        limit,
        daysBack: days_back,
      });
      // Merge and deduplicate results
    }

    return { content: [{ type: "text", text: formatResults(results) }] };
  },
);
```

### New get_conversation Tool

```typescript
server.tool(
  "get_conversation",
  "Retrieve full transcript of a past conversation by session ID.",
  {
    session_id: z.string().describe("Session ID to retrieve"),
  },
  async ({ session_id }) => {
    const conversation = await getConversationBySessionId(session_id);
    if (!conversation) {
      return { content: [{ type: "text", text: "Conversation not found." }] };
    }

    const formatted = formatTranscript(JSON.parse(conversation.transcript));
    return { content: [{ type: "text", text: formatted }] };
  },
);
```

## State of the Art

| Old Approach             | Current Approach       | When Changed        | Impact                             |
| ------------------------ | ---------------------- | ------------------- | ---------------------------------- |
| Markdown logs per day    | SQLite with session_id | Phase 7.2           | Enables search, prevents data loss |
| Manual context injection | SessionStart hook      | Claude CLI v1.0.85+ | Automatic, reliable                |
| No pre-compaction save   | PreCompact hook        | Claude CLI v1.0.85+ | Context preservation               |
| Global CLI assumption    | Exact path in hooks    | Phase 7.2           | Works without npm global install   |

## Open Questions

1. **Summary model choice**
   - What we know: OpenAI API already configured for embeddings
   - What's unclear: Use same model or Claude for summarization?
   - Recommendation: Use Claude API if available, fall back to OpenAI

2. **Summary length**
   - What we know: Summaries injected into SessionStart context
   - What's unclear: Optimal summary length for context budget?
   - Recommendation: 2-3 sentences max, configurable

3. **Conversation retention**
   - What we know: SQLite stores full transcripts
   - What's unclear: Retention policy? Disk space?
   - Recommendation: Keep all by default, add future cleanup command

4. **chatId tracking**
   - What we know: Need chatId for cron jobs
   - What's unclear: How to pass chatId to SessionEnd hook?
   - Recommendation: Store chatId in session metadata file, read in hook

## Sources

### Primary (HIGH confidence)

- [Claude Code Hooks Reference](https://code.claude.com/docs/en/hooks) - Complete hook API documentation
- [Drizzle ORM SQLite](https://orm.drizzle.team/docs/get-started-sqlite) - Setup and configuration
- [Drizzle ORM Migrations](https://orm.drizzle.team/docs/migrations) - Runtime migration patterns

### Secondary (MEDIUM confidence)

- [claude-code-transcripts](https://github.com/simonw/claude-code-transcripts) - JSONL transcript format
- [LLM Chat History Summarization Guide](https://mem0.ai/blog/llm-chat-history-summarization-guide-2025) - Summarization patterns

### Existing Code (HIGH confidence)

- `src/daemon/transcript.ts` - Transcript parsing pattern
- `src/memory/db.ts` - Current SQLite setup
- `src/memory/embeddings.ts` - Embedding storage pattern
- `src/mcp-server/tools/memory.ts` - MCP tool pattern

## Metadata

**Confidence breakdown:**

- Standard stack: HIGH - Drizzle ORM is well-documented, hooks API is official
- Architecture: HIGH - Follows existing codebase patterns
- Hook integration: HIGH - Official documentation verified
- Pitfalls: MEDIUM - Some edge cases may emerge during implementation

**Research date:** 2026-01-31
**Valid until:** 2026-03-31 (stable APIs, hook schema unlikely to change)
