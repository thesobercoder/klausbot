---
phase: 05-proactive
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/cron/executor.ts
  - src/cron/service.ts
  - src/cron/scheduler.ts
  - src/cron/index.ts
autonomous: true

must_haves:
  truths:
    - "Cron jobs execute via queryClaudeCode spawner"
    - "Execution results notify user via Telegram"
    - "Failed jobs retry once after delay"
    - "Scheduler runs sequential execution (one job at a time)"
    - "Job status (lastRunAtMs, lastStatus, lastError) persists after execution"
  artifacts:
    - path: "src/cron/executor.ts"
      provides: "Job execution via Claude Code"
      exports: ["executeCronJob"]
    - path: "src/cron/service.ts"
      provides: "CRUD operations for cron jobs"
      exports:
        ["createCronJob", "listCronJobs", "deleteCronJob", "updateCronJob"]
    - path: "src/cron/scheduler.ts"
      provides: "Background scheduling loop"
      exports: ["startScheduler", "stopScheduler"]
  key_links:
    - from: "src/cron/executor.ts"
      to: "src/daemon/spawner.ts"
      via: "imports queryClaudeCode"
      pattern: "import.*queryClaudeCode.*from.*spawner"
    - from: "src/cron/executor.ts"
      to: "src/telegram/bot.ts"
      via: "imports bot for notifications"
      pattern: "import.*bot.*from.*telegram"
    - from: "src/cron/scheduler.ts"
      to: "src/cron/executor.ts"
      via: "calls executeCronJob"
      pattern: "import.*executeCronJob.*from.*executor"
---

<objective>
Create cron execution engine: job executor with retry, CRUD service, and background scheduler.

Purpose: Enable cron jobs to actually run at scheduled times and notify users of results.
Output: Complete execution pipeline from scheduler loop to Telegram notification.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-proactive/05-RESEARCH.md
@.planning/phases/05-proactive/05-01-SUMMARY.md

Reference files:
@src/daemon/spawner.ts (queryClaudeCode pattern)
@src/daemon/gateway.ts (bot API usage pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cron executor with retry</name>
  <files>src/cron/executor.ts</files>
  <action>
Create src/cron/executor.ts with executeCronJob(job: CronJob):

Constants:

- CRON_TIMEOUT = 3600000 (1 hour per CONTEXT.md)
- RETRY_DELAY = 60000 (1 minute)

Implementation:

1. Call queryClaudeCode with job.instruction
   - Set timeout: CRON_TIMEOUT
   - Add additionalInstructions with cron context:

     ```
     <cron-execution>
     This is an autonomous cron job execution.
     Job name: ${job.name}
     Job ID: ${job.id}

     Complete the task and provide a concise result summary.
     </cron-execution>
     ```

2. On success: send result to user via bot.api.sendMessage(job.chatId, message)
   - Format: `[Cron: ${job.name}]\n${response.result}`
3. On failure: retry once after RETRY_DELAY
   - If retry succeeds: send success message
   - If retry fails: send failure message with error
4. Return { success: boolean, result: string, durationMs: number }

Import bot from '../telegram/bot.js' (not index to avoid circular deps).
Import queryClaudeCode from '../daemon/spawner.js'.
</action>
<verify>
npx tsc --noEmit src/cron/executor.ts
</verify>
<done>
executeCronJob spawns Claude, notifies user, retries on failure.
</done>
</task>

<task type="auto">
  <name>Task 2: Create CRUD service and scheduler loop</name>
  <files>src/cron/service.ts, src/cron/scheduler.ts, src/cron/index.ts</files>
  <action>
Create src/cron/service.ts with CRUD operations:
- createCronJob(params): generates UUID id, sets createdAt, computes nextRunAtMs, saves to store
- listCronJobs(chatId?): returns all jobs (optionally filtered by chatId)
- getCronJob(id): returns single job
- updateCronJob(id, updates): partial update, recalculates nextRunAtMs if schedule changed
- deleteCronJob(id): removes from store
- updateJobStatus(id, result): updates lastRunAtMs, lastStatus, lastError, lastDurationMs, nextRunAtMs

Create src/cron/scheduler.ts with:

State:

- schedulerInterval: NodeJS.Timeout | null
- isExecuting: boolean
- pendingJobs: CronJob[]

Functions:

- startScheduler(): starts setInterval(tick, 60000) - check every minute
- stopScheduler(): clears interval
- tick(): checkAndEnqueueDueJobs() then processNextJob()
- checkAndEnqueueDueJobs(): loads store, finds jobs where nextRunAtMs <= now, adds to pendingJobs
- processNextJob(): if !isExecuting and pendingJobs not empty, executes next job
- recoverMissedJobs(): on startup, run any jobs missed while offline (if missed < 24h)

Sequential execution: isExecuting flag prevents concurrent job runs.

Update src/cron/index.ts to export all new functions.
</action>
<verify>
npx tsc --noEmit src/cron/service.ts src/cron/scheduler.ts
npm run build
</verify>
<done>
CRUD service manages job lifecycle.
Scheduler loop checks for due jobs every minute, executes sequentially.
</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: npm run build
2. All functions exported via src/cron/index.ts
3. createCronJob generates valid job with nextRunAtMs
4. Scheduler tick enqueues due jobs
5. Executor uses 1-hour timeout
</verification>

<success_criteria>

- executeCronJob spawns Claude Code with cron context
- User receives Telegram notification on job completion
- Failed jobs retry once before final failure notification
- Scheduler loop runs every 60 seconds
- Sequential execution prevents concurrent job runs
  </success_criteria>

<output>
After completion, create `.planning/phases/05-proactive/05-02-SUMMARY.md`
</output>
