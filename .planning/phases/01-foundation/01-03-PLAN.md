---
phase: 01-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/daemon/queue.ts
  - src/daemon/spawner.ts
  - src/daemon/index.ts
autonomous: true

must_haves:
  truths:
    - "Queue persists messages to disk (survives restart)"
    - "Queue processes messages in FIFO order"
    - "Claude Code spawns successfully with inherited stdin"
    - "Spawner returns Claude response or throws descriptive error"
  artifacts:
    - path: "src/daemon/queue.ts"
      provides: "Persistent message queue"
      exports: ["MessageQueue", "QueuedMessage"]
    - path: "src/daemon/spawner.ts"
      provides: "Claude Code process spawner"
      exports: ["queryClaudeCode", "ClaudeResponse"]
  key_links:
    - from: "src/daemon/queue.ts"
      to: "fs"
      via: "writeFileSync/readFileSync"
      pattern: "writeFileSync.*queue"
    - from: "src/daemon/spawner.ts"
      to: "child_process"
      via: "spawn with inherited stdin"
      pattern: "stdio.*inherit"
---

<objective>
Create message queue with disk persistence and Claude Code spawner with inherited stdin workaround.

Purpose: Core daemon infrastructure - queue ensures no message loss on restart, spawner bridges to Claude Code.
Output: Working queue that survives restart, working spawner that invokes Claude CLI.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create persistent message queue</name>
  <files>src/daemon/queue.ts</files>
  <action>
Create src/daemon/queue.ts following RESEARCH.md Pattern 3:

Define QueuedMessage interface:

- id: string (UUID)
- chatId: number
- text: string
- timestamp: number
- status: 'pending' | 'processing' | 'done' | 'failed'
- error?: string (for failed messages)

Export class MessageQueue:

- private queue: QueuedMessage[]
- private path: string
- private logger: Logger (child logger)

Constructor(dataDir: string):

- Set path to {dataDir}/queue.json
- Ensure dataDir exists (mkdirSync recursive)
- Call load()

Private load():

- If file exists, read and parse JSON
- Filter out 'done' messages older than 1 hour
- Reset any 'processing' messages to 'pending' (recovery from crash)
- Persist cleaned queue

Private persist():

- writeFileSync with JSON.stringify (pretty print for debugging)
- Log on write errors but don't throw (non-critical)

Public add(chatId: number, text: string): string

- Generate UUID
- Push to queue with 'pending' status
- Persist immediately
- Return id

Public take(): QueuedMessage | undefined

- Find first 'pending' message
- Set status to 'processing'
- Persist
- Return message (or undefined if empty)

Public complete(id: string): void

- Find message, set status to 'done'
- Persist

Public fail(id: string, error: string): void

- Find message, set status to 'failed', add error
- Persist

Public getPending(): QueuedMessage[]

- Return copy of pending messages (for status display)

Public getStats(): { pending: number, processing: number, failed: number }

- Count by status
  </action>
  <verify>Unit test: add 3 messages, take 1, restart queue (new instance same path), verify 2 pending + 1 processing reset to pending</verify>
  <done>Queue persists to JSON, survives restart, tracks message status</done>
  </task>

<task type="auto">
  <name>Task 2: Create Claude Code spawner</name>
  <files>src/daemon/spawner.ts</files>
  <action>
Create src/daemon/spawner.ts following RESEARCH.md Pattern 1:

CRITICAL: Use stdio: ['inherit', 'pipe', 'pipe'] to avoid hang bug (issue #771)

Define ClaudeResponse interface:

- result: string
- cost_usd: number
- session_id: string
- duration_ms: number (we track this)
- is_error: boolean

Define SpawnerOptions interface:

- timeout?: number (default 300000 = 5 min)
- model?: string (for future /model command)

Export async function queryClaudeCode(prompt: string, options?: SpawnerOptions): Promise<ClaudeResponse>

Implementation:

- Create child logger for spawner
- Log prompt (truncated to 100 chars) and options
- Record start time

- spawn('claude', args, { stdio: ['inherit', 'pipe', 'pipe'], env: process.env })
- Args: ['-p', prompt, '--output-format', 'json']
- If options.model: add ['--model', options.model]

- Collect stdout and stderr
- Set up timeout that kills process if exceeded
- On 'close':
  - Clear timeout
  - Calculate duration
  - If code !== 0: reject with Error including stderr
  - Parse JSON from stdout
  - If parse fails: reject with raw stdout for debugging
  - Return ClaudeResponse with duration_ms added

- On 'error': reject with spawn failure message

Error messages should be user-friendly:

- "Claude timed out after {X} seconds"
- "Claude exited with code {X}: {stderr first 200 chars}"
- "Failed to parse Claude response: {first 100 chars of stdout}"
- "Failed to start Claude: {error message}"

Log all outcomes (success with duration, failure with reason).
</action>
<verify>Manual test with simple prompt: queryClaudeCode("Say hello").then(console.log) - verify response or clear error</verify>
<done>Spawner invokes Claude CLI with inherited stdin, handles timeout/errors, returns typed response</done>
</task>

<task type="auto">
  <name>Task 3: Create daemon index and ensure data directory</name>
  <files>src/daemon/index.ts</files>
  <action>
Create src/daemon/index.ts:
- Re-export MessageQueue, QueuedMessage from ./queue
- Re-export queryClaudeCode, ClaudeResponse, SpawnerOptions from ./spawner

- Export function ensureDataDir(path: string): void
  - mkdirSync(path, { recursive: true })
  - Create .gitkeep file if empty (for git tracking of structure)

- Export function getDataPath(subpath: string): string
  - Join config.DATA_DIR with subpath
  - Useful for consistent path construction
    </action>
    <verify>Build succeeds; imports work from daemon/index</verify>
    <done>Daemon module exports queue and spawner, provides data directory helpers</done>
    </task>

</tasks>

<verification>
After all tasks:
1. `npm run build` succeeds
2. Create test script:
   ```typescript
   import { MessageQueue, queryClaudeCode, ensureDataDir } from './daemon/index.js';
   import { config } from './config/index.js';

ensureDataDir(config.DATA_DIR);
const queue = new MessageQueue(config.DATA_DIR);

// Test queue persistence
const id1 = queue.add(123, 'Hello');
const id2 = queue.add(123, 'World');
console.log('Added:', id1, id2);
console.log('Stats:', queue.getStats());

const msg = queue.take();
console.log('Took:', msg?.text);
console.log('Stats after take:', queue.getStats());

// Test spawner (requires claude CLI installed)
const response = await queryClaudeCode('Say "test successful" and nothing else');
console.log('Claude response:', response.result);
console.log('Duration:', response.duration_ms, 'ms');

```
3. Run twice - second run should show queue recovered from disk
</verification>

<success_criteria>
- Queue persists to data/queue.json
- Queue recovers pending messages on restart
- 'processing' messages reset to 'pending' on restart (crash recovery)
- Spawner successfully invokes Claude CLI
- Spawner uses inherited stdin (no hang)
- Spawner respects timeout
- Clear error messages for all failure modes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
```
