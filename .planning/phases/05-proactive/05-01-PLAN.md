---
phase: 05-proactive
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cron/types.ts
  - src/cron/store.ts
  - src/cron/parse.ts
  - src/cron/schedule.ts
  - src/cron/index.ts
autonomous: true

must_haves:
  truths:
    - "CronJob type exists with all required fields (id, name, schedule, instruction, chatId, timestamps)"
    - "CronSchedule type supports at/every/cron kinds"
    - "Jobs persist to JSON file and survive process restart"
    - "parseSchedule converts natural language to CronSchedule"
    - "computeNextRunAtMs calculates next execution time correctly"
  artifacts:
    - path: "src/cron/types.ts"
      provides: "CronJob, CronSchedule, CronStoreFile types"
      exports: ["CronJob", "CronSchedule", "CronStoreFile", "ScheduleKind"]
    - path: "src/cron/store.ts"
      provides: "JSON persistence with atomic writes"
      exports: ["loadCronStore", "saveCronStore"]
    - path: "src/cron/parse.ts"
      provides: "Schedule parsing from user input"
      exports: ["parseSchedule", "ParsedSchedule"]
    - path: "src/cron/schedule.ts"
      provides: "Next run calculation"
      exports: ["computeNextRunAtMs"]
  key_links:
    - from: "src/cron/parse.ts"
      to: "src/cron/types.ts"
      via: "imports CronSchedule type"
      pattern: "import.*CronSchedule.*from.*types"
    - from: "src/cron/schedule.ts"
      to: "src/cron/types.ts"
      via: "imports CronSchedule type"
      pattern: "import.*CronSchedule.*from.*types"
---

<objective>
Create cron system foundation: types, JSON persistence, and schedule parsing.

Purpose: Enable cron jobs to be stored, parsed from natural language, and have their next run times calculated.
Output: Core cron module with types, store, and parsing utilities.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-proactive/05-RESEARCH.md

Reference files:
@src/memory/home.ts (getHomePath pattern)
@src/pairing/store.ts (JSON persistence pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cron types and store</name>
  <files>src/cron/types.ts, src/cron/store.ts</files>
  <action>
Create src/cron/types.ts with:
- ScheduleKind = 'at' | 'every' | 'cron'
- CronSchedule interface: { kind, atMs?, everyMs?, anchorMs?, expr?, tz? }
- CronJob interface: { id, name, schedule, instruction, chatId, createdAt, nextRunAtMs, lastRunAtMs, lastStatus, lastError, lastDurationMs, enabled, humanSchedule }
- CronStoreFile interface: { version: 1, jobs: CronJob[] }

Create src/cron/store.ts with:

- STORE_PATH = getHomePath('cron', 'jobs.json')
- loadCronStore(): reads JSON file, returns { version: 1, jobs: [] } if missing
- saveCronStore(store): atomic write via temp file + rename (use crypto.randomUUID for temp suffix)

Follow existing patterns from src/pairing/store.ts for JSON persistence.
</action>
<verify>
TypeScript compiles: npx tsc --noEmit src/cron/types.ts src/cron/store.ts
</verify>
<done>
CronJob, CronSchedule, CronStoreFile types exist. Store loads/saves atomically.
</done>
</task>

<task type="auto">
  <name>Task 2: Create schedule parsing and next-run calculation</name>
  <files>src/cron/parse.ts, src/cron/schedule.ts, src/cron/index.ts</files>
  <action>
Install dependencies: npm install croner chrono-node

Create src/cron/parse.ts with parseSchedule(input: string): ParsedSchedule | null

- Pattern 1: "every X (minute|hour|day|week)s?" -> everyMs schedule
- Pattern 2: Cron expression (starts with digit or \*) -> use Cron from croner
- Pattern 3: Natural language date -> use chrono.parse
- Return { schedule: CronSchedule, humanReadable: string, nextRun: Date | null }

Create src/cron/schedule.ts with computeNextRunAtMs(schedule, nowMs?):

- 'at': return atMs if > nowMs, else null
- 'every': calculate next interval from anchor
- 'cron': use Cron.nextRun() from croner with timezone option

Create src/cron/index.ts barrel export:

- Export all from types.ts, store.ts, parse.ts, schedule.ts

Handle edge cases:

- Invalid cron expressions: return null
- Past dates: return null for 'at' type
- Timezone: respect schedule.tz for cron expressions
  </action>
  <verify>
  npm install croner chrono-node
  npx tsc --noEmit src/cron/index.ts
  Manual test: node -e "import('./dist/cron/index.js').then(m => console.log(m.parseSchedule('every 5 minutes')))"
  </verify>
  <done>
  parseSchedule handles natural language, intervals, and cron expressions.
  computeNextRunAtMs calculates correct next run for all schedule types.
  </done>
  </task>

</tasks>

<verification>
1. TypeScript compiles with no errors: npm run build
2. Types are exported: import { CronJob, CronSchedule } from './cron/index.js'
3. Store creates jobs.json on first save
4. parseSchedule returns valid schedules for:
   - "every 5 minutes"
   - "0 9 * * *"
   - "tomorrow at 9am"
5. computeNextRunAtMs returns future timestamps
</verification>

<success_criteria>

- src/cron/ directory exists with types.ts, store.ts, parse.ts, schedule.ts, index.ts
- All types and functions exported via index.ts
- npm run build succeeds
- JSON store uses atomic write pattern (temp + rename)
  </success_criteria>

<output>
After completion, create `.planning/phases/05-proactive/05-01-SUMMARY.md`
</output>
