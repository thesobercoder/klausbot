---
phase: 01-foundation
plan: 05
type: execute
wave: 4
depends_on: ["01-02", "01-03", "01-04"]
files_modified:
  - src/daemon/gateway.ts
  - src/utils/git.ts
  - src/telegram/commands.ts
  - src/telegram/handlers.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Gateway wires bot -> queue -> spawner -> response"
    - "User message triggers Claude response via Telegram"
    - "Status progression shown during processing"
    - "Errors surfaced to user with category (not stack trace)"
    - "Queue processes messages in order"
    - "File changes auto-committed after Claude response"
  artifacts:
    - path: "src/daemon/gateway.ts"
      provides: "Main processing loop"
      exports: ["startGateway", "stopGateway"]
    - path: "src/utils/git.ts"
      provides: "Git auto-commit utility"
      exports: ["autoCommitChanges"]
    - path: "src/index.ts"
      provides: "Entry point and CLI dispatcher"
  key_links:
    - from: "src/daemon/gateway.ts"
      to: "src/daemon/queue.ts"
      via: "queue.take() -> process -> complete/fail"
      pattern: "queue\\.take"
    - from: "src/daemon/gateway.ts"
      to: "src/daemon/spawner.ts"
      via: "queryClaudeCode call"
      pattern: "queryClaudeCode"
    - from: "src/telegram/handlers.ts"
      to: "src/daemon/queue.ts"
      via: "queue.add on message"
      pattern: "queue\\.add"
    - from: "src/daemon/gateway.ts"
      to: "src/utils/git.ts"
      via: "autoCommitChanges after Claude response"
      pattern: "autoCommitChanges"
---

<objective>
Wire all components into working gateway: bot receives message, queues it, spawns Claude, sends response, auto-commits any file changes.

Purpose: Complete the core message flow - the fundamental value loop of klausbot.
Output: Working end-to-end flow from Telegram message to Claude response with version control.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.planning/phases/01-foundation/01-03-SUMMARY.md
@.planning/phases/01-foundation/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gateway processing loop</name>
  <files>src/daemon/gateway.ts</files>
  <action>
Create src/daemon/gateway.ts:

Import all components:

- bot, createRunner, MyContext from ../telegram
- MessageQueue, queryClaudeCode from ./index
- initPairingStore, createPairingMiddleware, handleStartCommand from ../pairing
- config, logger, sendLongMessage from respective modules
- autoCommitChanges from ../utils/git

Module state:

- let queue: MessageQueue
- let isProcessing: boolean = false
- let shouldStop: boolean = false
- const statusMessageIds: Map<number, number> = new Map()
  (tracks status message ID per chatId for later update/deletion)

Export async function startGateway(): Promise<void>

1. Initialize:
   - ensureDataDir(config.DATA_DIR)
   - queue = new MessageQueue(config.DATA_DIR)
   - initPairingStore(config.DATA_DIR)
   - Log startup stats (pending messages, approved users)

2. Setup bot middleware (ORDER MATTERS):
   - Pairing middleware first (blocks unapproved)
   - Then commands and handlers

3. Update /start command handler to use handleStartCommand from pairing

4. Update message handler to:
   - Add message to queue: queue.add(ctx.chat.id, ctx.message.text)
   - Send status message and store ID:
     const statusMsg = await ctx.reply("Queued. Processing...")
     statusMessageIds.set(ctx.chat.id, statusMsg.message_id)
   - Log: message queued { chatId, queueId }
   - Start processing if not already running

5. Start processing loop (non-blocking):
   - processQueue() runs in background
   - Doesn't block bot polling

6. Create runner and wait for shutdown

Export async function stopGateway(): Promise<void>

- shouldStop = true
- Wait for current processing to finish (with timeout)
- Stop runner

Private async function processQueue(): Promise<void>

- If isProcessing, return (already running)
- isProcessing = true
- While !shouldStop:
  - const msg = queue.take()
  - If no msg: wait 100ms, continue
  - await processMessage(msg)
- isProcessing = false

Private async function processMessage(msg: QueuedMessage): Promise<void>

1. Update status message to "Thinking...":
   - Get statusMsgId from statusMessageIds.get(msg.chatId)
   - If exists, use bot.api.editMessageText(msg.chatId, statusMsgId, "Thinking...")
   - If edit fails (message deleted), send new status

2. Call queryClaudeCode(msg.text) with try/catch

3. On success:
   - queue.complete(msg.id)
   - Delete status message if exists:
     bot.api.deleteMessage(msg.chatId, statusMsgId).catch(() => {})
     statusMessageIds.delete(msg.chatId)
   - Send response via sendLongMessage (handles splitting)
   - Log: message processed { chatId, queueId, duration }
   - AUTO-COMMIT: Call autoCommitChanges() to commit any file changes Claude made

4. On error:
   - Determine error category (timeout, spawn failure, parse error)
   - Format user-friendly message: "Error ({category}): {brief description}"
   - Update/send error to user
   - queue.fail(msg.id, error.message)
   - Log: message failed { chatId, queueId, error }
   - statusMessageIds.delete(msg.chatId)

Status message progression (CONTEXT.md requirement):

- Use bot.api.editMessageText to update status
- "Thinking..." -> response (or error)
- For MVP, single status is fine; progression can be enhanced later
  </action>
  <verify>Manual test: send message, verify status appears, Claude responds, status updates/clears</verify>
  <done>Gateway wires all components, processes queue, shows status, handles errors, tracks status messages via Map</done>
  </task>

<task type="auto">
  <name>Task 2: Create git auto-commit utility</name>
  <files>src/utils/git.ts</files>
  <action>
Create src/utils/git.ts to satisfy EVOL-04 (all self-modifications version controlled):

Import:

- spawn from child_process
- logger from ./logger
- config from ../config

Export async function autoCommitChanges(): Promise<boolean>
Purpose: After Claude responds, check for uncommitted changes and auto-commit them.

Implementation:

1. Check if in git repo:
   - Run: git rev-parse --is-inside-work-tree
   - If fails or returns false, log warning and return false (not a git repo)

2. Check for changes:
   - Run: git status --porcelain
   - If empty output, return false (no changes)

3. Stage all changes:
   - Run: git add -A
   - Log: staging changes

4. Create commit:
   - Run: git commit -m "chore(klausbot): auto-commit Claude modifications"
   - Include timestamp in commit body for traceability
   - Log: committed changes { files_changed }
   - Return true

5. On any git error:
   - Log error but don't throw (non-critical)
   - Return false

Helper function runGit(args: string[]): Promise<{ stdout: string, stderr: string, code: number }>

- Spawn git with args
- Return output and exit code
- Handle spawn errors gracefully

Logging:

- Log when changes detected and committed
- Log when no changes found (debug level)
- Log any git errors (warn level)
  </action>
  <verify>Modify a file, call autoCommitChanges(), verify git log shows new commit</verify>
  <done>Git utility auto-commits file changes after Claude modifications</done>
  </task>

<task type="auto">
  <name>Task 3: Update handlers to integrate with queue</name>
  <files>src/telegram/handlers.ts, src/telegram/commands.ts</files>
  <action>
Update src/telegram/handlers.ts:

Remove placeholder echo logic. Instead:

- Accept queue parameter or import from daemon
- On message:text:
  - Log incoming message
  - queue.add(ctx.chat.id, ctx.message.text)
  - Send status message (gateway handles ID tracking)
  - Trigger processQueue (if exported) or just let gateway handle it

Export function setupHandlers(queue: MessageQueue, processCallback: () => void):

- Wire queue.add
- Call processCallback after adding (triggers processing)

Update src/telegram/commands.ts:

Update /start to use handleStartCommand from pairing:

- Import handleStartCommand from ../pairing
- bot.command('start', handleStartCommand)

Update /model to be more informative:

- Reply: "Current model: default\nModel switching coming in Phase 2"

Add /status command (useful for debugging):

- Show queue stats: pending, processing, failed
- Show if user is approved
- bot.command('status', handler)

Add /help command:

- List available commands
- "Send any message to chat with Claude"
  </action>
  <verify>Build succeeds; commands respond correctly; messages queue properly</verify>
  <done>Handlers wire to queue, commands updated for pairing integration</done>
  </task>

<task type="auto">
  <name>Task 4: Create entry point and CLI dispatcher</name>
  <files>src/index.ts</files>
  <action>
Create src/index.ts as single entry point:

Parse command line args (simple, no library needed for MVP):

- process.argv[2] is subcommand
- Subcommands: daemon, pairing, help

If no subcommand or 'daemon':

- Import and call startGateway()
- This is the main mode

If 'pairing':

- process.argv[3] is action: approve, reject, list, revoke
- process.argv[4] is argument (code or chatId)

- 'pairing approve <code>':
  - Load PairingStore directly (don't start bot)
  - Call store.approvePairing(code)
  - Print success or "Code not found"
  - Exit

- 'pairing reject <code>':
  - Call store.rejectPairing(code)
  - Print result and exit

- 'pairing list':
  - Print pending requests (code, chatId, username, age)
  - Print approved users (chatId, username, age)
  - Exit

- 'pairing revoke <chatId>':
  - Call store.revoke(parseInt(chatId))
  - Print result and exit

If 'help':

- Print usage:

  ```
  klausbot - Telegram gateway for Claude Code

  Usage:
    klausbot [daemon]              Start the gateway daemon
    klausbot pairing approve <code>   Approve pairing request
    klausbot pairing reject <code>    Reject pairing request
    klausbot pairing list             List pending/approved
    klausbot pairing revoke <chatId>  Revoke access
    klausbot help                     Show this help
  ```

Update package.json scripts:

- "start": "node dist/index.js"
- "dev": "tsx src/index.ts"
- Add "bin" field: { "klausbot": "./dist/index.js" }
  </action>
  <verify>npm run build; node dist/index.js help shows usage; node dist/index.js pairing list works</verify>
  <done>Single entry point dispatches to daemon or CLI commands</done>
  </task>

</tasks>

<verification>
After all tasks:
1. `npm run build` succeeds
2. Full flow test:
   a. Start daemon: `node dist/index.js`
   b. New user sends message -> blocked, told to /start
   c. User sends /start -> gets pairing code
   d. In another terminal: `node dist/index.js pairing approve <code>`
   e. User sends message -> sees "Thinking...", gets Claude response
   f. Long response splits correctly
   g. Ctrl+C stops daemon gracefully
   h. Restart daemon -> queue state preserved

3. Auto-commit test:
   - Send message that causes Claude to modify a file
   - Verify `git log` shows "chore(klausbot): auto-commit Claude modifications"
   - If no changes, verify no empty commits created

4. Error handling test:
   - Kill Claude mid-process (if possible) -> user sees error message
   - Send very long message -> handled (queued, processed)

5. Status commands:
   - /status shows queue stats
   - /help lists commands
     </verification>

<success_criteria>

- Complete message flow: Telegram -> Queue -> Claude -> Response
- Pairing flow works end-to-end
- CLI commands work (pairing approve/reject/list/revoke)
- Status message shown during processing (tracked via Map<chatId, messageId>)
- Errors surfaced to user (category + description, no stack traces)
- Queue persists across restart
- Graceful shutdown
- EVOL-04 satisfied: File changes auto-committed to git after Claude response
  </success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-05-SUMMARY.md`
</output>
