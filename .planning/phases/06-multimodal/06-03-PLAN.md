---
phase: 06-multimodal
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - src/daemon/queue.ts
  - src/daemon/gateway.ts
autonomous: true

must_haves:
  truths:
    - "QueuedMessage can carry media attachments"
    - "Voice messages are transcribed before Claude processing"
    - "Images are saved and paths included in prompt"
    - "Media processing errors surface to user with actionable messages"
  artifacts:
    - path: "src/daemon/queue.ts"
      provides: "Extended QueuedMessage with media field"
      contains: "media?: MediaAttachment[]"
    - path: "src/daemon/gateway.ts"
      provides: "Media pre-processing in processMessage"
      contains: "processMedia"
  key_links:
    - from: "src/daemon/queue.ts"
      to: "src/media/types.ts"
      via: "MediaAttachment import"
      pattern: "import.*MediaAttachment.*from.*media"
    - from: "src/daemon/gateway.ts"
      to: "src/media/index.ts"
      via: "transcribeAudio, saveImage imports"
      pattern: "import.*from.*media"
    - from: "src/daemon/gateway.ts"
      to: "src/daemon/spawner.ts"
      via: "queryClaudeCode with enriched prompt"
      pattern: "queryClaudeCode"
    - from: "src/daemon/gateway.ts"
      to: "src/media/retry.ts"
      via: "withRetry wrapper for transcription"
      pattern: "withRetry.*transcribeAudio"
---

<objective>
Extend queue and gateway to process media messages.

Purpose: Enable voice transcription and image handling in the message processing pipeline.
Output: Media-aware queue, pre-processing pipeline in gateway.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-multimodal/06-CONTEXT.md
@.planning/phases/06-multimodal/06-RESEARCH.md
@src/daemon/queue.ts
@src/daemon/gateway.ts
@src/daemon/spawner.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend QueuedMessage with media support</name>
  <files>src/daemon/queue.ts</files>
  <action>
Read current `src/daemon/queue.ts`.

Add import at top:

```typescript
import type { MediaAttachment } from "../media/index.js";
```

Extend QueuedMessage interface to add optional media field:

```typescript
export interface QueuedMessage {
  id: string;
  chatId: number;
  text: string;
  timestamp: number;
  status: MessageStatus;
  error?: string;
  media?: MediaAttachment[]; // NEW: attached media
}
```

Update `add` method signature to accept optional media:

```typescript
add(chatId: number, text: string, media?: MediaAttachment[]): string
```

In add method, include media in the message object:

```typescript
const message: QueuedMessage = {
  id,
  chatId,
  text,
  timestamp: Date.now(),
  status: "pending",
  media, // NEW
};
```

No other changes needed â€” existing persist/load will handle the new field.
</action>
<verify>

1. `npx tsc --noEmit` passes
2. `grep "media?" src/daemon/queue.ts` shows media field
3. `grep "MediaAttachment" src/daemon/queue.ts` shows import
   </verify>
   <done>

- QueuedMessage has optional media field
- queue.add accepts optional media array
- Media persisted with message
  </done>
  </task>

<task type="auto">
  <name>Task 2: Media pre-processing in gateway</name>
  <files>src/daemon/gateway.ts</files>
  <action>
Read current `src/daemon/gateway.ts`.

Add imports at top:

```typescript
import {
  MediaAttachment,
  transcribeAudio,
  isTranscriptionAvailable,
  saveImage,
  withRetry,
} from "../media/index.js";
import { unlinkSync } from "fs";
```

Add new helper function `processMedia`:

```typescript
/**
 * Pre-process media attachments before Claude query
 * - Voice: transcribe and delete audio file
 * - Photo: save to images directory
 *
 * @returns Processed attachments with transcripts/paths filled in
 */
async function processMedia(
  attachments: MediaAttachment[],
): Promise<{ processed: MediaAttachment[]; errors: string[] }> {
  const processed: MediaAttachment[] = [];
  const errors: string[] = [];

  for (const attachment of attachments) {
    const startTime = Date.now();

    if (attachment.type === "voice") {
      // Transcribe voice
      if (!isTranscriptionAvailable()) {
        errors.push(
          "Voice transcription not available (OPENAI_API_KEY missing)",
        );
        continue;
      }

      if (!attachment.localPath) {
        errors.push("Voice file not downloaded");
        continue;
      }

      try {
        const result = await withRetry(() =>
          transcribeAudio(attachment.localPath!),
        );

        // Delete audio file after transcription (per CONTEXT.md)
        try {
          unlinkSync(attachment.localPath);
        } catch {
          // Ignore delete errors
        }

        processed.push({
          ...attachment,
          transcript: result.text,
          processingTimeMs: Date.now() - startTime,
          localPath: undefined, // Clear path since file deleted
        });

        log.info(
          {
            type: "voice",
            transcriptLength: result.text.length,
            durationMs: result.durationMs,
          },
          "Transcribed voice message",
        );
      } catch (err) {
        const msg = err instanceof Error ? err.message : String(err);
        errors.push(`Transcription failed: ${msg}`);
        log.error(
          { err, localPath: attachment.localPath },
          "Voice transcription failed",
        );
      }
    } else if (attachment.type === "photo") {
      // Save image
      if (!attachment.localPath) {
        errors.push("Image file not downloaded");
        continue;
      }

      try {
        const savedPath = saveImage(attachment.localPath);

        processed.push({
          ...attachment,
          localPath: savedPath, // Update to permanent path
          processingTimeMs: Date.now() - startTime,
        });

        log.info({ type: "photo", savedPath }, "Saved image");
      } catch (err) {
        const msg = err instanceof Error ? err.message : String(err);
        errors.push(`Failed to save image: ${msg}`);
        log.error(
          { err, localPath: attachment.localPath },
          "Image save failed",
        );
      }
    }
  }

  return { processed, errors };
}
```

Add helper to build prompt with media context:

```typescript
/**
 * Build prompt text incorporating media context
 */
function buildPromptWithMedia(text: string, media: MediaAttachment[]): string {
  const voiceTranscripts = media
    .filter((m) => m.type === "voice" && m.transcript)
    .map((m) => m.transcript);

  const imagePaths = media
    .filter((m) => m.type === "photo" && m.localPath)
    .map((m) => m.localPath!);

  let prompt = text;

  // If voice-only (no text), use transcript as prompt
  if (!text.trim() && voiceTranscripts.length > 0) {
    prompt = voiceTranscripts.join("\n");
  } else if (voiceTranscripts.length > 0) {
    // Text + voice: prepend transcript context
    prompt = `[Voice message transcript: ${voiceTranscripts.join(" ")}]\n\n${text}`;
  }

  // Add image references for Claude to read
  if (imagePaths.length > 0) {
    const imageInstructions = imagePaths
      .map((p, i) => `Image ${i + 1}: ${p}`)
      .join("\n");

    prompt = `The user sent ${imagePaths.length} image(s). Read and analyze them using your Read tool:\n${imageInstructions}\n\n${prompt || "(no text, just the image(s))"}`;
  }

  return prompt;
}
```

Modify `processMessage` function to handle media:

After the existing `logUserMessage(msg.text);` line, add media processing:

```typescript
// Process media attachments if present
let effectiveText = msg.text;
let mediaErrors: string[] = [];

if (msg.media && msg.media.length > 0) {
  const { processed, errors } = await processMedia(msg.media);
  mediaErrors = errors;

  if (processed.length > 0) {
    effectiveText = buildPromptWithMedia(msg.text, processed);

    // Log image paths to conversation (per CONTEXT.md)
    for (const m of processed) {
      if (m.type === "photo" && m.localPath) {
        logUserMessage(`[Image: ${m.localPath}]`);
      }
    }
  }
}

// If all media failed and no text, send error and return
if (mediaErrors.length > 0 && !effectiveText.trim()) {
  clearInterval(typingInterval);
  queue.fail(msg.id, mediaErrors.join("; "));
  await bot.api.sendMessage(
    msg.chatId,
    `Could not process media: ${mediaErrors.join(". ")}`,
  );
  return;
}
```

Update the queryClaudeCode call to use effectiveText instead of msg.text:

```typescript
const response = await queryClaudeCode(effectiveText, {
  additionalInstructions,
});
```

If there were non-fatal media errors, append them to Claude's response:

```typescript
// After sending response, if there were media errors, note them
if (mediaErrors.length > 0 && !response.is_error) {
  await bot.api.sendMessage(
    msg.chatId,
    `Note: Some media could not be processed: ${mediaErrors.join(". ")}`,
  );
}
```

  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `grep "processMedia" src/daemon/gateway.ts` shows function exists
3. `grep "buildPromptWithMedia" src/daemon/gateway.ts` shows function exists
4. `grep "import.*media" src/daemon/gateway.ts` shows media imports
5. `grep "withRetry.*transcribeAudio" src/daemon/gateway.ts` shows retry wiring
  </verify>
  <done>
- processMedia transcribes voice (with retry), saves images
- buildPromptWithMedia constructs Claude prompt with media context
- processMessage handles media before Claude query
- Media errors surfaced to user
  </done>
</task>

</tasks>

<verification>
```bash
# All files compile
npx tsc --noEmit

# Queue has media support

grep "media" src/daemon/queue.ts

# Gateway has media processing

grep -E "processMedia|buildPromptWithMedia" src/daemon/gateway.ts

# Retry wiring confirmed

grep "withRetry" src/daemon/gateway.ts

```
</verification>

<success_criteria>
- QueuedMessage interface includes optional media field
- queue.add accepts media parameter
- processMedia function transcribes voice (with withRetry) and saves images
- buildPromptWithMedia constructs prompt with media context
- processMessage pre-processes media before Claude query
- Media errors surfaced to user with actionable messages
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-multimodal/06-03-SUMMARY.md`
</output>
```
