---
phase: 14-testing-framework
plan: 03
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - tests/unit/daemon/queue.test.ts
  - tests/unit/daemon/spawner.test.ts
  - tests/unit/daemon/gateway.test.ts
  - tests/unit/memory/conversations.test.ts
  - tests/unit/memory/context.test.ts
autonomous: true

must_haves:
  truths:
    - "MessageQueue adds, takes, completes, fails messages with correct status transitions"
    - "MessageQueue persists to disk and recovers processing messages on restart"
    - "parseTranscript handles valid JSONL, malformed lines, and empty input"
    - "extractConversationText combines user/assistant entries from both string and array content formats"
    - "Thread detection identifies active conversation chains within 30-minute gaps"
    - "buildConversationContext produces tiered XML output with correct thread-status tags"
    - "getMcpConfig returns valid MCP server config using process.argv"
    - "getHooksConfig returns hooks for SessionStart, PreCompact, SessionEnd"
    - "writeMcpConfigFile writes JSON to temp file and returns path"
    - "gateway buildPromptWithMedia produces correct prompts for voice, photo, and mixed media"
    - "gateway categorizeError classifies timeout, spawn, parse, and process errors"
    - "gateway summarizeToolUse formats tool entries into readable strings"
  artifacts:
    - path: "tests/unit/daemon/queue.test.ts"
      provides: "MessageQueue unit tests"
      min_lines: 60
    - path: "tests/unit/daemon/spawner.test.ts"
      provides: "Spawner config and argument construction tests"
      min_lines: 40
    - path: "tests/unit/daemon/gateway.test.ts"
      provides: "Gateway helper function tests"
      min_lines: 50
    - path: "tests/unit/memory/conversations.test.ts"
      provides: "parseTranscript + extractConversationText unit tests"
      min_lines: 40
    - path: "tests/unit/memory/context.test.ts"
      provides: "Thread detection + buildConversationContext tests"
      min_lines: 80
  key_links:
    - from: "tests/unit/daemon/queue.test.ts"
      to: "src/daemon/queue.ts"
      via: "import MessageQueue"
      pattern: "import.*MessageQueue"
    - from: "tests/unit/daemon/spawner.test.ts"
      to: "src/daemon/spawner.ts"
      via: "import getMcpConfig, getHooksConfig, writeMcpConfigFile"
      pattern: "import.*(getMcpConfig|getHooksConfig|writeMcpConfigFile)"
    - from: "tests/unit/daemon/gateway.test.ts"
      to: "src/daemon/gateway.ts"
      via: "testing exported and internal helper functions"
      pattern: "import.*(categorizeError|getLastActiveChatId)"
    - from: "tests/unit/memory/context.test.ts"
      to: "src/memory/context.ts"
      via: "import buildConversationContext"
      pattern: "import.*buildConversationContext"
    - from: "tests/unit/memory/conversations.test.ts"
      to: "src/memory/conversations.ts"
      via: "import parseTranscript, extractConversationText"
      pattern: "import.*(parseTranscript|extractConversationText)"
---

<objective>
Unit tests for stateful P0/P1 modules plus gateway and spawner helper functions: MessageQueue (filesystem), transcript parsing (pure logic), conversation context building (DB + thread detection), spawner config generation, and gateway utility functions.

Purpose: These modules handle persistence, conversation intelligence, Claude CLI invocation config, and message routing — the core of klausbot's runtime. Testing them with mocked I/O ensures correctness without external dependencies.
Output: 5 test files covering queue lifecycle, transcript parsing, conversation context, spawner config, and gateway helpers.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-testing-framework/14-RESEARCH.md
@src/daemon/queue.ts
@src/daemon/spawner.ts
@src/daemon/gateway.ts
@src/memory/conversations.ts
@src/memory/context.ts
@src/memory/schema.ts
@src/memory/db.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: MessageQueue unit tests with temp directory</name>
  <files>tests/unit/daemon/queue.test.ts</files>
  <action>
Create `tests/unit/daemon/queue.test.ts` testing MessageQueue from `../../../src/daemon/queue.js`.

**Mocking:** Must mock the logger before importing MessageQueue. Use vi.mock:

```typescript
vi.mock("../../../src/utils/logger.js", () => ({
  createChildLogger: () => ({
    info: vi.fn(),
    debug: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  }),
}));
```

**Setup/teardown:** Use `mkdtempSync` + `rmSync` for isolated temp directories per test suite.

**Test cases:**

**add and take:**

- add(12345, "hello") returns a UUID string
- take() returns the added message with status "processing"
- take() on empty queue returns undefined
- Multiple adds, take returns FIFO order

**complete and fail:**

- complete(id) sets status to "done"
- fail(id, "error msg") sets status to "failed" and records error
- complete/fail with unknown id does not throw (logs warning)

**getStats:**

- Empty queue: pending 0, processing 0, failed 0
- After add: pending 1
- After add + take: processing 1
- After add + take + complete: all 0 (done messages counted separately)
- After add + take + fail: failed 1

**getPending:**

- Returns copies of pending messages (not references)
- Excludes processing/done/failed messages

**Persistence and crash recovery:**

- Create queue, add message, create NEW queue from same directory -> message is loaded
- Add message, take (status=processing), create NEW queue -> message recovered to "pending"
- Old done messages (timestamp > 1hr ago) filtered out on load

**Threading context:**

- add() with threading parameter preserves messageThreadId and replyToMessageId
- take() returns message with threading context intact

**Media attachments:**

- add() with media array preserves attachments
- take() returns message with media intact
  </action>
  <verify>`npx vitest run tests/unit/daemon/queue.test.ts --reporter=verbose` — all tests pass, temp dirs cleaned up</verify>
  <done>MessageQueue fully tested: add/take/complete/fail lifecycle, stats tracking, disk persistence, crash recovery, threading context, and media attachments.</done>
  </task>

<task type="auto">
  <name>Task 2: Conversation parsing and context building tests</name>
  <files>tests/unit/memory/conversations.test.ts, tests/unit/memory/context.test.ts</files>
  <action>
1. Create `tests/unit/memory/conversations.test.ts` testing pure functions from `../../../src/memory/conversations.js`:

**parseTranscript:**

- Valid JSONL (2 lines) -> returns 2 entries with correct types
- Malformed line mixed with valid -> skips malformed, returns valid entries
- Empty string -> returns []
- Single line -> returns 1 entry

**extractConversationText:**

- User and assistant entries with array content -> "User: ...\n\nAssistant: ..."
- Entry with string content (not array) -> handles correctly
- Entry with no text content -> skipped
- Mixed entry types (summary, system) -> only user/assistant included
- Empty entries array -> returns ""

These functions are pure — no mocking needed. Import directly.

2. Create `tests/unit/memory/context.test.ts` testing context building functions from `../../../src/memory/context.js`:

   **Mocking strategy:** The context module imports `getConversationsForContext` from conversations.ts (which calls getDrizzle), `getHomePath` from home.ts, and `existsSync`/`readFileSync` from fs. We need to mock:
   - `../../../src/memory/conversations.js` to control getConversationsForContext return values
   - `../../../src/memory/home.js` to return temp paths for getHomePath
   - `fs` module: mock `existsSync` and `readFileSync` for identity file tests

   Use `vi.mock` for module-level mocking. Use `vi.hoisted` for values needed in mock factories.

   **Test the exported functions that don't need DB:**

   **getRetrievalInstructions:**
   - Returns string containing "memory-instructions" XML tag
   - Contains "search_memories" tool mention
   - Contains "MANDATORY" enforcement text

   **getSkillReminder / getAgentReminder / getToolGuidance:**
   - Each returns string wrapped in correct XML tags

   **getOrchestrationInstructions:**
   - Contains "start_background_task" mention
   - Contains "60 SECONDS" kill warning

   **getMemoryFirstBookend / getMemoryFirstReminder:**
   - Return strings with correct XML tag names

   **buildConversationContext (mocked conversations):**
   Set up `vi.mocked(getConversationsForContext)` to return controlled data.

   Create fixture conversations using `createConversationRecord` from helpers, with specific timestamps to test tiering:
   - **No conversations:** Returns ""
   - **Active thread (within 30min):** Returns XML with `<thread-status>CONTINUATION`
   - **New conversation (>30min gap):** Returns XML with `<thread-status>NEW CONVERSATION`
   - **Tiered output:** Create convs at: 5min ago (thread), 2hr ago (today), 30hr ago (yesterday), 4 days ago (older). Verify:
     - Thread conv has full `<conversation>` with transcript entries
     - Today conv has full transcript
     - Yesterday conv has `summary="true"` attribute
     - Older conv has `summary="true"` attribute
   - **Budget enforcement:** Create a conversation with very long transcript (>120K chars). Verify output is truncated and contains "[...truncated...]"

   **loadIdentity / reloadIdentity / invalidateIdentityCache:**
   - Mock fs.existsSync to return true for identity files
   - Mock fs.readFileSync to return test content
   - Mock getHomePath to return deterministic paths
   - loadIdentity returns XML-wrapped content
   - invalidateIdentityCache + loadIdentity reloads (returns new content if readFileSync mock changed)
   - reloadIdentity forces fresh read

   **buildSystemPrompt:**
   - When BOOTSTRAP.md exists -> returns its content only
   - When no BOOTSTRAP.md + identity files exist -> returns combined prompt with all sections

   Note: Use `vi.resetModules()` in beforeEach if testing identity cache behavior, since it uses module-level state.
   </action>
   <verify>`npx vitest run tests/unit/memory/ --reporter=verbose` — all tests pass</verify>
   <done>Conversation parsing tested with pure functions. Context building tested with mocked DB layer, covering thread detection (continuation vs new), tiered formatting (full vs summary), budget enforcement, identity loading, and system prompt composition.</done>
   </task>

<task type="auto">
  <name>Task 3: Spawner config and gateway helper unit tests</name>
  <files>tests/unit/daemon/spawner.test.ts, tests/unit/daemon/gateway.test.ts</files>
  <action>
1. Create `tests/unit/daemon/spawner.test.ts` testing the pure/config functions from `../../../src/daemon/spawner.js`:

**Mocking:** Mock the logger and memory module to prevent side effects:

```typescript
vi.mock("../../../src/utils/logger.js", () => ({
  createChildLogger: () => ({
    info: vi.fn(),
    debug: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
  }),
}));
vi.mock("../../../src/memory/index.js", () => ({
  KLAUSBOT_HOME: "/tmp/klausbot-test",
  buildSystemPrompt: vi.fn().mockReturnValue("test system prompt"),
}));
vi.mock("../../../src/daemon/transcript.js", () => ({
  handleTimeout: vi.fn().mockReturnValue(null),
}));
```

**getMcpConfig:**

- Returns object with `mcpServers.klausbot` key
- `command` is `process.argv[0]` (node executable)
- `args` is `[process.argv[1], "mcp"]`
- `env` is an empty object

**getHooksConfig:**

- Returns object with `hooks` key
- Has `SessionStart`, `PreCompact`, `SessionEnd` arrays
- SessionStart matcher contains "startup|resume"
- Each hook has `type: "command"` and `timeout` number
- Hook commands contain `process.argv[0]` and `process.argv[1]`

**writeMcpConfigFile:**

- Returns a string path containing "klausbot-mcp" and process.pid
- File exists at the returned path
- File content is valid JSON matching getMcpConfig() output
- Clean up the temp file after test

**ToolUseEntry and ClaudeResponse types:**

- Import and verify they are valid TypeScript interfaces (type-level test)

Do NOT test `queryClaudeCode` directly — it spawns child processes. That's covered by integration tests.

2. Create `tests/unit/daemon/gateway.test.ts` testing gateway helper functions.

   **Challenge:** gateway.ts has many module-level side effects and mostly private functions. Strategy: test the few exported functions directly, and test internal helpers by extracting testable patterns.

   **Mocking:** Mock all heavy dependencies to prevent import side effects:

   ```typescript
   vi.mock("../../../src/utils/logger.js", () => ({
     createChildLogger: () => ({
       info: vi.fn(),
       debug: vi.fn(),
       warn: vi.fn(),
       error: vi.fn(),
     }),
   }));
   vi.mock("../../../src/telegram/index.js", () => ({
     streamToTelegram: vi.fn(),
     canStreamToChat: vi.fn(),
     bot: {
       api: { sendMessage: vi.fn(), sendChatAction: vi.fn() },
       use: vi.fn(),
       command: vi.fn(),
       on: vi.fn(),
     },
     createRunner: vi.fn(),
     registerSkillCommands: vi.fn(),
     getInstalledSkillNames: vi.fn().mockReturnValue([]),
     translateSkillCommand: vi.fn((t: string) => t),
   }));
   vi.mock("../../../src/daemon/index.js", () => ({
     MessageQueue: vi.fn(),
     queryClaudeCode: vi.fn(),
     ensureDataDir: vi.fn(),
     spawnBackgroundAgent: vi.fn(),
   }));
   vi.mock("../../../src/config/index.js", () => ({
     getJsonConfig: vi.fn().mockReturnValue({ streaming: { enabled: false } }),
   }));
   vi.mock("../../../src/pairing/index.js", () => ({
     initPairingStore: vi.fn(),
     createPairingMiddleware: vi.fn(),
     handleStartCommand: vi.fn(),
     getPairingStore: vi.fn(),
   }));
   vi.mock("../../../src/memory/index.js", () => ({
     initializeHome: vi.fn(),
     initializeEmbeddings: vi.fn(),
     migrateEmbeddings: vi.fn(),
     closeDb: vi.fn(),
     invalidateIdentityCache: vi.fn(),
     runMigrations: vi.fn(),
     getOrchestrationInstructions: vi.fn(),
     storeConversation: vi.fn(),
     buildConversationContext: vi.fn().mockReturnValue(""),
   }));
   vi.mock("../../../src/memory/home.js", () => ({
     KLAUSBOT_HOME: "/tmp/test",
   }));
   vi.mock("../../../src/bootstrap/index.js", () => ({
     needsBootstrap: vi.fn().mockReturnValue(false),
     DEFAULT_BOOTSTRAP_CONTENT: "",
   }));
   vi.mock("../../../src/platform/index.js", () => ({
     validateRequiredCapabilities: vi.fn(),
   }));
   vi.mock("../../../src/cron/index.js", () => ({
     startScheduler: vi.fn(),
     stopScheduler: vi.fn(),
     loadCronStore: vi.fn().mockReturnValue({ jobs: [] }),
   }));
   vi.mock("../../../src/heartbeat/index.js", () => ({
     startHeartbeat: vi.fn(),
     stopHeartbeat: vi.fn(),
     shouldCollectNote: vi.fn().mockReturnValue(false),
     getNoteCollectionInstructions: vi.fn(),
   }));
   vi.mock("../../../src/utils/git.js", () => ({ autoCommitChanges: vi.fn() }));
   vi.mock("../../../src/utils/index.js", () => ({
     createChildLogger: () => ({
       info: vi.fn(),
       debug: vi.fn(),
       warn: vi.fn(),
       error: vi.fn(),
     }),
     sendLongMessage: vi.fn(),
     markdownToTelegramHtml: vi.fn((t: string) => t),
     splitTelegramMessage: vi.fn((t: string) => [t]),
   }));
   vi.mock("../../../src/media/index.js", () => ({
     transcribeAudio: vi.fn(),
     isTranscriptionAvailable: vi.fn(),
     saveImage: vi.fn(),
     withRetry: vi.fn(),
     downloadFile: vi.fn(),
   }));
   vi.mock("../../../src/daemon/task-watcher.js", () => ({
     startTaskWatcher: vi.fn().mockReturnValue(() => {}),
   }));
   ```

   **getLastActiveChatId:**
   - Initially returns null (no messages processed)
   - Import and call directly

   **categorizeError (test via re-implementation or export):**
   Since categorizeError is not exported, test the pattern by verifying error categorization behavior through the module. Alternatively, if the function can be imported via internal access, test:
   - Error with "timeout" -> "timeout"
   - Error with "spawn" -> "spawn"
   - Error with "parse" or "json" -> "parse"
   - Error with "exit" -> "process"
   - Unknown error -> "unknown"

   Note: If categorizeError and summarizeToolUse are not exported (they're private), skip direct unit testing of those. Focus on getLastActiveChatId (exported) and verify the module loads without errors. The private helper logic will be covered by integration tests in Plan 14-05.

   **buildPromptWithMedia (private, test pattern):**
   If accessible, test:
   - Text only -> returns text unchanged
   - Voice transcript only (no text) -> transcript becomes prompt
   - Text + voice -> prepend "[Voice message transcript: ...]"
   - Photo paths -> prepend "The user sent N image(s)..."
   - Both voice + photo + text -> combined prompt

   If private functions are inaccessible, document this in the test file and test only exported functions. The integration test plan (14-05) covers the full flow.
   </action>
   <verify>`npx vitest run tests/unit/daemon/ --reporter=verbose` — all tests pass</verify>
   <done>Spawner config functions tested: getMcpConfig, getHooksConfig, writeMcpConfigFile all verified. Gateway exported functions tested. Module loads cleanly with mocked dependencies.</done>
   </task>

</tasks>

<verification>
- `npm test` passes all tests (plans 02 and 03 combined)
- `npm run test:coverage` shows meaningful coverage on daemon/queue.ts, daemon/spawner.ts, daemon/gateway.ts, memory/conversations.ts, memory/context.ts
- No real database, filesystem (outside temp), or network calls in any test
</verification>

<success_criteria>

1. MessageQueue: full lifecycle (add/take/complete/fail), persistence, crash recovery tested
2. parseTranscript + extractConversationText: pure function tests with edge cases
3. buildConversationContext: thread detection, tiered formatting, budget enforcement tested
4. Identity loading and system prompt composition tested
5. Spawner: getMcpConfig, getHooksConfig, writeMcpConfigFile tested
6. Gateway: getLastActiveChatId tested, module loads without import errors
7. All tests pass on `npm test`
   </success_criteria>

<output>
After completion, create `.planning/phases/14-testing-framework/14-03-SUMMARY.md`
</output>
