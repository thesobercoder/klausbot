---
phase: 01-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-01"]
files_modified:
  - src/pairing/store.ts
  - src/pairing/flow.ts
  - src/pairing/index.ts
autonomous: true

must_haves:
  truths:
    - "Pairing store persists approved users to disk"
    - "/start generates unique pairing code"
    - "CLI can approve pairing code"
    - "Unapproved users receive 'waiting for approval' message"
    - "Approved users pass through to message handling"
  artifacts:
    - path: "src/pairing/store.ts"
      provides: "Persistent pairing state"
      exports: ["PairingStore", "PairingState"]
    - path: "src/pairing/flow.ts"
      provides: "Pairing flow logic"
      exports: ["createPairingMiddleware", "handleStartCommand"]
  key_links:
    - from: "src/pairing/store.ts"
      to: "fs"
      via: "JSON file persistence"
      pattern: "writeFileSync.*pairing"
    - from: "src/pairing/flow.ts"
      to: "src/pairing/store.ts"
      via: "isApproved check"
      pattern: "isApproved.*chatId"
---

<objective>
Implement moltbot-style pairing flow with persistent allowlist and CLI approval.

Purpose: Security boundary - only paired users can interact with the bot.
Output: Working pairing flow where /start generates code, CLI approves, unauthorized blocked.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pairing store with persistence</name>
  <files>src/pairing/store.ts</files>
  <action>
Create src/pairing/store.ts following RESEARCH.md Pattern 4:

Define interfaces:

- ApprovedUser: { approvedAt: number, username?: string, firstName?: string }
- PendingRequest: { chatId: number, requestedAt: number, username?: string, firstName?: string }
- PairingState: { approved: Record<string, ApprovedUser>, pending: Record<string, PendingRequest> }
  - Use string keys for JSON serialization (chatId.toString() for approved)

Export class PairingStore:

- private state: PairingState
- private path: string
- private logger: Logger

Constructor(dataDir: string):

- Set path to {dataDir}/pairing.json
- Call load()

Private load():

- If file exists, read and parse
- Otherwise initialize empty state

Private persist():

- writeFileSync with pretty JSON

Public generateCode(): string

- Generate 6-char alphanumeric (crypto.randomBytes(3).toString('hex').toUpperCase())
- Check for collision in pending (regenerate if exists - unlikely but safe)
- Return code

Public requestPairing(chatId: number, username?: string, firstName?: string): string

- Check if already approved -> return special value (e.g., 'ALREADY_APPROVED')
- Check if already pending -> return existing code
- Generate new code
- Add to pending with timestamp
- Persist
- Log: pairing requested { code, chatId, username }
- Return code

Public approvePairing(code: string): { chatId: number, username?: string } | null

- Find in pending
- If not found, return null
- Move to approved (chatId as string key)
- Remove from pending
- Persist
- Log: pairing approved { code, chatId }
- Return { chatId, username }

Public rejectPairing(code: string): boolean

- Remove from pending if exists
- Persist
- Log: pairing rejected { code }
- Return true if was pending

Public isApproved(chatId: number): boolean

- Return chatId.toString() in approved

Public listPending(): Array<{ code: string, chatId: number, username?: string, requestedAt: number }>

- Return array for CLI display

Public listApproved(): Array<{ chatId: number, username?: string, approvedAt: number }>

- Return array for CLI display

Public revoke(chatId: number): boolean

- Remove from approved if exists
- Persist
- Log: pairing revoked { chatId }
- Return true if was approved
  </action>
  <verify>Unit test: request -> approve -> isApproved returns true; restart store -> still approved</verify>
  <done>Pairing store persists to JSON, supports full pairing lifecycle</done>
  </task>

<task type="auto">
  <name>Task 2: Create pairing flow middleware and command handlers</name>
  <files>src/pairing/flow.ts</files>
  <action>
Create src/pairing/flow.ts:

Import:

- MyContext from ../telegram/bot
- PairingStore from ./store
- logger from ../utils

Let store: PairingStore (module-level, initialized lazily)

Export function initPairingStore(dataDir: string): PairingStore

- Create store if not exists
- Return store

Export function handleStartCommand(ctx: MyContext): Promise<void>

- Get chatId, username, firstName from ctx
- Call store.requestPairing(chatId, username, firstName)
- If 'ALREADY_APPROVED':
  - Reply: "You're already paired! Send me a message."
- Else:
  - Reply with formatted message:

    ```
    Welcome! To complete pairing, run this command on the server:

    klausbot pairing approve {code}

    Your chat ID: {chatId}
    ```

  - Log: pairing code shown to user

Export function createPairingMiddleware():

- Return async middleware function (ctx, next)
- If ctx.chat is undefined, skip (shouldn't happen)
- If store.isApproved(ctx.chat.id), call next()
- Else:
  - Check if this is /start command -> allow through (handled separately)
  - Otherwise reply: "Waiting for approval. Use /start to get a pairing code."
  - Log: blocked unapproved user { chatId }
  - Do NOT call next()

Export function getPairingStore(): PairingStore

- Return store (for CLI access)
- Throw if not initialized
  </action>
  <verify>Manual test: new user sends message -> blocked; /start -> gets code; hardcode approve -> messages work</verify>
  <done>Pairing middleware blocks unapproved, /start generates code, approval flow works</done>
  </task>

<task type="auto">
  <name>Task 3: Create pairing module index</name>
  <files>src/pairing/index.ts</files>
  <action>
Create src/pairing/index.ts:
- Re-export PairingStore, PairingState, ApprovedUser, PendingRequest from ./store
- Re-export initPairingStore, handleStartCommand, createPairingMiddleware, getPairingStore from ./flow

This provides clean import path: import { PairingStore, createPairingMiddleware } from './pairing'
</action>
<verify>Build succeeds; can import all exports from pairing/index</verify>
<done>Clean module exports for pairing functionality</done>
</task>

</tasks>

<verification>
After all tasks:
1. `npm run build` succeeds
2. Create test script:
   ```typescript
   import { PairingStore, initPairingStore, createPairingMiddleware } from './pairing/index.js';
   import { config } from './config/index.js';

// Test store directly
const store = new PairingStore(config.DATA_DIR);

const code = store.requestPairing(123456, 'testuser', 'Test');
console.log('Pairing code:', code);
console.log('Is approved:', store.isApproved(123456)); // false

const result = store.approvePairing(code);
console.log('Approved:', result);
console.log('Is approved now:', store.isApproved(123456)); // true

console.log('Pending:', store.listPending()); // empty
console.log('Approved list:', store.listApproved()); // has our user

```
3. Verify data/pairing.json created with correct structure
4. Restart and verify state persisted
</verification>

<success_criteria>
- Pairing store persists to data/pairing.json
- Code generation is unique (no collision)
- /start returns code for new users, "already paired" for approved
- Middleware blocks unapproved users with clear message
- Approved users pass through to next middleware
- Full audit trail in logs
- State survives restart
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-04-SUMMARY.md`
</output>
```
