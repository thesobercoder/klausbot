# Phase 7.1: Memory Search MCP - Research

**Researched:** 2026-01-30
**Domain:** SQLite vector storage, MCP tool development
**Confidence:** HIGH

## Summary

Phase 7.1 migrates embeddings from a single JSON file to SQLite with vector search, then exposes a `search_memories` MCP tool. The current system stores embeddings in `~/.klausbot/embeddings.json` but Claude cannot query them - this phase closes that gap.

**Stack choice:** better-sqlite3 + sqlite-vec extension for vector storage/KNN search. Follows established MCP pattern from Phase 5.1 (existing MCP server with cron tools).

**Primary recommendation:** Add sqlite-vec to existing better-sqlite3 DB, migrate JSON embeddings on first load, add `search_memories` tool to existing MCP server.

## Current State Analysis

### Existing Embeddings Implementation

| File                       | Purpose                                            |
| -------------------------- | -------------------------------------------------- |
| `src/memory/embeddings.ts` | Generate/store embeddings to JSON                  |
| `src/memory/search.ts`     | Cosine similarity search (unused by Claude)        |
| `src/memory/logger.ts`     | Calls `storeEmbedding()` after assistant responses |

**Current schema (`~/.klausbot/embeddings.json`):**

```typescript
interface EmbeddingEntry {
  id: string; // e.g., "assistant-2026-01-29-1706520000000-abc123"
  text: string; // Conversation chunk (max 500 chars)
  embedding: number[]; // 1536-dim float32 (text-embedding-3-small)
  timestamp: string; // ISO 8601
  source: string; // e.g., "assistant-2026-01-29"
}
```

**Gap:** `semanticSearch()` in `search.ts` works but Claude never calls it. No MCP tool exposes this functionality.

### Existing MCP Server

| File                           | Purpose                      |
| ------------------------------ | ---------------------------- |
| `src/mcp-server/index.ts`      | Entry point, stdio transport |
| `src/mcp-server/tools/cron.ts` | Cron CRUD tools              |

Pattern established: Zod schemas for params, text content responses, graceful error messages.

## Standard Stack

### Core

| Library        | Version | Purpose                 | Why Standard                                    |
| -------------- | ------- | ----------------------- | ----------------------------------------------- |
| better-sqlite3 | ^12.x   | SQLite driver           | Fastest Node.js SQLite, sync API, battle-tested |
| sqlite-vec     | ^0.1.7  | Vector search extension | Official KNN extension, SIMD-optimized, pure C  |

### Supporting (Already Installed)

| Library                   | Version | Purpose              |
| ------------------------- | ------- | -------------------- |
| @modelcontextprotocol/sdk | ^1.25.3 | MCP server framework |
| openai                    | ^6.17.0 | Embedding generation |
| zod                       | ^4.3.6  | Schema validation    |

### Why better-sqlite3 + sqlite-vec

| Alternative              | Why Not                                                |
| ------------------------ | ------------------------------------------------------ |
| sql.js                   | 50-60% performance of native, designed for browser     |
| node:sqlite              | Zero deps but newer, less ecosystem support            |
| Dedicated vector DB      | Overkill for personal assistant, adds infra complexity |
| JSON + cosine similarity | Already have this - doesn't scale, linear scan O(n)    |

**Installation:**

```bash
npm install better-sqlite3 sqlite-vec
npm install --save-dev @types/better-sqlite3
```

## Architecture Patterns

### Recommended File Structure

```
src/
  memory/
    embeddings.ts       # Update: SQLite instead of JSON
    search.ts           # Update: Use sqlite-vec KNN
    migrate.ts          # NEW: JSON to SQLite migration
  mcp-server/
    index.ts            # Update: Register memory tools
    tools/
      cron.ts           # Existing
      memory.ts         # NEW: search_memories tool
```

### Database Schema

```sql
-- Main embeddings table
CREATE TABLE IF NOT EXISTS embeddings (
  id TEXT PRIMARY KEY,
  text TEXT NOT NULL,
  timestamp TEXT NOT NULL,
  source TEXT NOT NULL
);

-- Vector index for KNN search (1536 dims = OpenAI text-embedding-3-small)
CREATE VIRTUAL TABLE IF NOT EXISTS vec_embeddings USING vec0(
  embedding float[1536]
);

-- Index for date filtering
CREATE INDEX IF NOT EXISTS idx_embeddings_timestamp ON embeddings(timestamp);
CREATE INDEX IF NOT EXISTS idx_embeddings_source ON embeddings(source);
```

**Key insight:** vec0 uses rowid to link to main table. Insert embedding with same rowid as main table entry.

### Pattern: Vector Insert

```typescript
import Database from "better-sqlite3";
import * as sqliteVec from "sqlite-vec";

const db = new Database(getHomePath("memory.db"));
sqliteVec.load(db);

// Enable WAL for performance
db.pragma("journal_mode = WAL");

// Insert with matching rowid
const insertMain = db.prepare(`
  INSERT INTO embeddings (id, text, timestamp, source)
  VALUES (?, ?, ?, ?)
`);
const insertVec = db.prepare(`
  INSERT INTO vec_embeddings (rowid, embedding)
  VALUES (?, ?)
`);

const storeEmbedding = db.transaction((entry: EmbeddingEntry) => {
  const info = insertMain.run(
    entry.id,
    entry.text,
    entry.timestamp,
    entry.source,
  );
  const rowid = info.lastInsertRowid;
  // Convert to Float32Array buffer for sqlite-vec
  const buffer = new Float32Array(entry.embedding).buffer;
  insertVec.run(rowid, buffer);
});
```

### Pattern: KNN Search with Date Filter

```typescript
interface SearchParams {
  query: string;
  limit?: number;
  daysBack?: number;
}

async function searchMemories(params: SearchParams): Promise<SearchResult[]> {
  const { query, limit = 5, daysBack } = params;

  // Generate query embedding
  const queryEmbedding = await generateEmbedding(query);
  if (!queryEmbedding) return [];

  const queryBuffer = new Float32Array(queryEmbedding).buffer;

  // Build SQL with optional date filter
  let sql = `
    SELECT e.id, e.text, e.timestamp, e.source, v.distance
    FROM vec_embeddings v
    JOIN embeddings e ON e.rowid = v.rowid
    WHERE v.embedding MATCH ?
  `;
  const params: unknown[] = [queryBuffer];

  if (daysBack) {
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - daysBack);
    sql += ` AND e.timestamp >= ?`;
    params.push(cutoff.toISOString());
  }

  sql += ` ORDER BY v.distance LIMIT ?`;
  params.push(limit);

  return db
    .prepare(sql)
    .all(...params)
    .map((row) => ({
      text: row.text,
      score: 1 - row.distance, // Convert distance to similarity
      source: row.source,
      timestamp: row.timestamp,
    }));
}
```

### MCP Tool Definition

```typescript
// src/mcp-server/tools/memory.ts
import { z } from "zod";
import type { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { searchMemories } from "../../memory/search.js";

export function registerMemoryTools(server: McpServer): void {
  server.tool(
    "search_memories",
    "Search past conversations semantically to recall what was discussed",
    {
      query: z.string().describe("What to search for (natural language)"),
      limit: z.number().optional().describe("Max results (default: 5)"),
      daysBack: z.number().optional().describe("Only search last N days"),
    },
    async ({ query, limit, daysBack }) => {
      const results = await searchMemories({ query, limit, daysBack });

      if (results.length === 0) {
        return {
          content: [
            {
              type: "text" as const,
              text: "No relevant memories found for this query.",
            },
          ],
        };
      }

      const formatted = results
        .map(
          (r, i) =>
            `${i + 1}. [${r.timestamp.split("T")[0]}] (score: ${r.score.toFixed(2)})\n${r.text}`,
        )
        .join("\n\n");

      return {
        content: [
          {
            type: "text" as const,
            text: `Found ${results.length} relevant memories:\n\n${formatted}`,
          },
        ],
      };
    },
  );
}
```

## Don't Hand-Roll

| Problem                  | Don't Build        | Use Instead         | Why                              |
| ------------------------ | ------------------ | ------------------- | -------------------------------- |
| Vector similarity search | Linear scan cosine | sqlite-vec KNN      | O(log n) vs O(n), SIMD optimized |
| Float32 serialization    | Manual buffer math | Float32Array.buffer | Built-in, correct endianness     |
| Atomic DB writes         | File rename tricks | SQLite transactions | ACID guarantees                  |
| Extension loading        | Manual dlopen      | sqlite-vec.load()   | Handles platform differences     |

## Common Pitfalls

### Pitfall 1: Embedding Dimension Mismatch

**What goes wrong:** vec0 table created with wrong dimensions
**Why it happens:** Different OpenAI models have different dimensions
**How to avoid:** Always use 1536 (text-embedding-3-small), document in schema
**Warning signs:** "dimension mismatch" errors on insert

### Pitfall 2: Buffer Format for sqlite-vec

**What goes wrong:** Passing raw number[] instead of Float32Array buffer
**Why it happens:** JavaScript arrays aren't binary-compatible
**How to avoid:** Always wrap: `new Float32Array(embedding).buffer`
**Warning signs:** Garbled results or insertion errors

### Pitfall 3: Missing rowid Linkage

**What goes wrong:** vec0 entries not linked to main table
**Why it happens:** vec0 requires explicit rowid, not auto-generated
**How to avoid:** Get lastInsertRowid from main insert, use for vec insert
**Warning signs:** Joins return no results

### Pitfall 4: Migration Race Condition

**What goes wrong:** Embeddings written to JSON during migration
**Why it happens:** Logger calls storeEmbedding while migration runs
**How to avoid:** Check for .db file existence before JSON fallback
**Warning signs:** Duplicate entries, lost data

### Pitfall 5: WAL Mode Not Enabled

**What goes wrong:** Poor write performance, locks
**Why it happens:** SQLite default is rollback journal
**How to avoid:** Call `db.pragma('journal_mode = WAL')` on init
**Warning signs:** Slow inserts, "database is locked" errors

## Migration Strategy

### JSON to SQLite Migration

```typescript
// src/memory/migrate.ts
import { existsSync, readFileSync, renameSync } from "fs";
import { getHomePath } from "./home.js";
import type { EmbeddingEntry } from "./embeddings.js";

const JSON_PATH = getHomePath("embeddings.json");
const BACKUP_PATH = getHomePath("embeddings.json.migrated");

export function migrateEmbeddings(db: Database): { migrated: number } {
  // Skip if no JSON file or already migrated
  if (!existsSync(JSON_PATH)) {
    return { migrated: 0 };
  }

  // Load JSON
  const content = readFileSync(JSON_PATH, "utf-8");
  const data = JSON.parse(content) as { entries: EmbeddingEntry[] };

  if (!data.entries || data.entries.length === 0) {
    // Empty file, just rename
    renameSync(JSON_PATH, BACKUP_PATH);
    return { migrated: 0 };
  }

  // Migrate in transaction
  const insertMain = db.prepare(`
    INSERT OR IGNORE INTO embeddings (id, text, timestamp, source)
    VALUES (?, ?, ?, ?)
  `);
  const insertVec = db.prepare(`
    INSERT OR IGNORE INTO vec_embeddings (rowid, embedding)
    VALUES (?, ?)
  `);

  const migrate = db.transaction((entries: EmbeddingEntry[]) => {
    for (const entry of entries) {
      const info = insertMain.run(
        entry.id,
        entry.text,
        entry.timestamp,
        entry.source,
      );
      if (info.changes > 0) {
        const buffer = new Float32Array(entry.embedding).buffer;
        insertVec.run(info.lastInsertRowid, buffer);
      }
    }
    return entries.length;
  });

  const count = migrate(data.entries);

  // Backup old JSON (don't delete - user might want it)
  renameSync(JSON_PATH, BACKUP_PATH);

  return { migrated: count };
}
```

### Migration Timing

Run migration in `initializeEmbeddings()`:

1. Open/create SQLite database
2. Create tables if not exist
3. Check for embeddings.json
4. If exists, migrate and rename to .migrated
5. Continue with SQLite operations

## Code Examples

### Database Initialization

```typescript
// src/memory/embeddings.ts (updated)
import Database, { Database as DatabaseType } from "better-sqlite3";
import * as sqliteVec from "sqlite-vec";
import { getHomePath } from "./home.js";
import { migrateEmbeddings } from "./migrate.js";

let db: DatabaseType | null = null;

function getDatabase(): DatabaseType {
  if (db) return db;

  const dbPath = getHomePath("memory.db");
  db = new Database(dbPath);
  sqliteVec.load(db);

  // Enable WAL mode
  db.pragma("journal_mode = WAL");

  // Create tables
  db.exec(`
    CREATE TABLE IF NOT EXISTS embeddings (
      id TEXT PRIMARY KEY,
      text TEXT NOT NULL,
      timestamp TEXT NOT NULL,
      source TEXT NOT NULL
    );

    CREATE VIRTUAL TABLE IF NOT EXISTS vec_embeddings USING vec0(
      embedding float[1536]
    );

    CREATE INDEX IF NOT EXISTS idx_embeddings_timestamp
      ON embeddings(timestamp);
  `);

  // Migrate from JSON if needed
  const { migrated } = migrateEmbeddings(db);
  if (migrated > 0) {
    console.log(
      `[embeddings] Migrated ${migrated} entries from JSON to SQLite`,
    );
  }

  return db;
}

export function initializeEmbeddings(): void {
  getDatabase(); // Triggers init + migration
}
```

### Store Embedding (Updated)

```typescript
export async function storeEmbedding(
  text: string,
  source: string,
): Promise<void> {
  const embedding = await generateEmbedding(text);
  if (!embedding) return;

  const db = getDatabase();
  const timestamp = new Date().toISOString();
  const id = `${source}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

  const insertMain = db.prepare(`
    INSERT INTO embeddings (id, text, timestamp, source)
    VALUES (?, ?, ?, ?)
  `);
  const insertVec = db.prepare(`
    INSERT INTO vec_embeddings (rowid, embedding)
    VALUES (?, ?)
  `);

  const store = db.transaction(() => {
    const info = insertMain.run(id, text, timestamp, source);
    const buffer = new Float32Array(embedding).buffer;
    insertVec.run(info.lastInsertRowid, buffer);
  });

  store();
}
```

## Open Questions

1. **Database file location**
   - What we know: `~/.klausbot/` is the data home
   - Recommendation: `~/.klausbot/memory.db` (alongside embeddings.json during transition)

2. **Chunking behavior**
   - What we know: Current implementation chunks at 500 chars
   - Recommendation: Keep chunking, each chunk gets separate rowid

3. **Score threshold**
   - What we know: Current code uses 0.7 minimum similarity
   - Recommendation: Make configurable via tool param, default 0.5 (sqlite-vec uses distance not similarity)

## Sources

### Primary (HIGH confidence)

- [better-sqlite3 GitHub](https://github.com/WiseLibs/better-sqlite3) - API reference
- [sqlite-vec GitHub](https://github.com/asg017/sqlite-vec) - vec0 syntax, KNN queries
- [sqlite-vec JS docs](https://alexgarcia.xyz/sqlite-vec/js.html) - Node.js integration

### Secondary (MEDIUM confidence)

- [SQLite-vec Node.js tutorial](https://dev.to/stephenc222/how-to-use-sqlite-vec-to-store-and-query-vector-embeddings-58mf) - Implementation patterns

### Existing Code (HIGH confidence)

- `src/memory/embeddings.ts` - Current JSON implementation
- `src/mcp-server/tools/cron.ts` - MCP tool pattern to follow

## Metadata

**Confidence breakdown:**

- Standard stack: HIGH - better-sqlite3 + sqlite-vec are the standard choices for embedded vector search
- Architecture: HIGH - follows existing MCP pattern from Phase 5.1
- Migration: MEDIUM - standard approach but edge cases possible
- Pitfalls: HIGH - well-documented in official sources

**Research date:** 2026-01-30
**Valid until:** 2026-03-30 (stable libraries, unlikely to change)
