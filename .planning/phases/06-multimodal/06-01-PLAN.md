---
phase: 06-multimodal
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/media/types.ts
  - src/media/download.ts
  - src/media/transcribe.ts
  - src/media/retry.ts
autonomous: true

must_haves:
  truths:
    - "Voice messages can be transcribed to text"
    - "Telegram voice files can be downloaded locally"
    - "Transcription errors provide actionable guidance (rate limit, timeout, or detailed message)"
  artifacts:
    - path: "src/media/types.ts"
      provides: "MediaAttachment interface, MediaType enum"
      exports: ["MediaAttachment", "MediaType", "TranscriptionResult"]
    - path: "src/media/download.ts"
      provides: "Telegram file download via @grammyjs/files"
      exports: ["downloadFile", "hydrateFilesOnBot"]
    - path: "src/media/transcribe.ts"
      provides: "Whisper API transcription"
      exports: ["transcribeAudio", "isTranscriptionAvailable"]
    - path: "src/media/retry.ts"
      provides: "Exponential backoff retry for transient failures"
      exports: ["withRetry", "isTransientError"]
  key_links:
    - from: "src/media/download.ts"
      to: "@grammyjs/files"
      via: "hydrateFiles plugin"
      pattern: "hydrateFiles"
    - from: "src/media/transcribe.ts"
      to: "openai"
      via: "audio.transcriptions.create"
      pattern: "openai\\.audio\\.transcriptions"
---

<objective>
Create media foundation: types, Telegram file download, and Whisper transcription.

Purpose: Enable voice message processing by establishing core media types and transcription capability.
Output: Four source files providing typed media handling, audio transcription, and retry logic.
</objective>

<execution_context>
@/home/soham/.claude/get-shit-done/workflows/execute-plan.md
@/home/soham/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-multimodal/06-CONTEXT.md
@.planning/phases/06-multimodal/06-RESEARCH.md
@src/telegram/bot.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Media types and download helper</name>
  <files>src/media/types.ts, src/media/download.ts</files>
  <action>
Install @grammyjs/files plugin:
```bash
npm install @grammyjs/files
```

Create `src/media/types.ts`:

- `MediaType` enum: 'voice' | 'photo'
- `MediaAttachment` interface:
  - type: MediaType
  - fileId: string (Telegram file_id)
  - localPath?: string (after download)
  - transcript?: string (for voice after transcription)
  - mimeType?: string
  - processingTimeMs?: number
- `TranscriptionResult` interface:
  - text: string
  - durationMs: number
- Export all types

Create `src/media/download.ts`:

- Import `hydrateFiles` from `@grammyjs/files`
- Export `hydrateFilesOnBot(bot: Bot, token: string)` — applies plugin to bot.api.config
- Export `downloadFile(bot: Bot, fileId: string, destPath: string): Promise<string>`:
  - Call `bot.api.getFile(fileId)`
  - Call `file.download(destPath)` (method added by hydrateFiles)
  - Return local path
  - Wrap in try/catch, throw descriptive error on failure
- Use pino logger (createChildLogger('media:download'))
  </action>
  <verify>

1. `npm ls @grammyjs/files` shows installed
2. `npx tsc --noEmit` passes
3. Both files export expected symbols
   </verify>
   <done>

- MediaAttachment and MediaType types exported from types.ts
- downloadFile function downloads Telegram files to specified path
- hydrateFilesOnBot applies grammY files plugin
  </done>
  </task>

<task type="auto">
  <name>Task 2: Whisper transcription</name>
  <files>src/media/transcribe.ts</files>
  <action>
Create `src/media/transcribe.ts`:

Import OpenAI from openai package (already installed).
Import createReadStream from fs.
Import createChildLogger from utils.

Export `isTranscriptionAvailable(): boolean`:

- Return true if `process.env.OPENAI_API_KEY` exists and non-empty
- Log warning if not available

Export `transcribeAudio(audioPath: string): Promise<TranscriptionResult>`:

- Check isTranscriptionAvailable() first, throw Error if not
- Create OpenAI client (reads OPENAI_API_KEY automatically)
- Call openai.audio.transcriptions.create with:
  - file: createReadStream(audioPath)
  - model: 'whisper-1'
  - (no language param — auto-detect)
- Track duration with Date.now() before/after
- Return { text: transcription.text, durationMs }
- Wrap in try/catch:
  - If error message contains 'rate limit' or '429', throw Error with 'Rate limited' prefix
  - If error message contains 'timeout' or '503', throw Error with 'Timeout' prefix
  - Otherwise throw Error with 'Transcription failed: ' + original message
- Log transcription success with text length and duration
  </action>
  <verify>

1. `npx tsc --noEmit` passes
2. isTranscriptionAvailable returns boolean based on env var
3. Function signature matches TranscriptionResult type
   </verify>
   <done>

- isTranscriptionAvailable checks OPENAI_API_KEY presence
- transcribeAudio calls Whisper API and returns typed result
- Errors categorized (rate limit, timeout, other)
  </done>
  </task>

<task type="auto">
  <name>Task 3: Exponential backoff retry utility</name>
  <files>src/media/retry.ts</files>
  <action>
Create `src/media/retry.ts`:

Export `isTransientError(err: Error): boolean`:

- Check message.toLowerCase() for: 'timeout', 'rate limit', '503', '429', 'econnreset', 'etimedout'
- Return true if any match

Export `withRetry<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T>`:

- RetryOptions: { maxRetries?: number, baseDelayMs?: number }
- Defaults: maxRetries = 3, baseDelayMs = 1000
- Loop up to maxRetries:
  - Try fn()
  - On success, return result
  - On error:
    - If not isTransientError, rethrow immediately
    - Calculate delay: baseDelayMs \* 2^attempt (1s, 2s, 4s)
    - await delay
    - Continue loop
- If all retries exhausted, throw last error
- Log each retry attempt with attempt number and delay
  </action>
  <verify>

1. `npx tsc --noEmit` passes
2. withRetry exported with generic type
3. isTransientError exported
   </verify>
   <done>

- withRetry implements exponential backoff (1s, 2s, 4s)
- isTransientError identifies retryable errors
- Non-transient errors fail immediately without retry
  </done>
  </task>

</tasks>

<verification>
```bash
# All files compile
npx tsc --noEmit

# Package installed

npm ls @grammyjs/files

# Files exist with exports

grep -l "export" src/media/\*.ts

```
</verification>

<success_criteria>
- @grammyjs/files installed
- src/media/types.ts exports MediaAttachment, MediaType, TranscriptionResult
- src/media/download.ts exports downloadFile, hydrateFilesOnBot
- src/media/transcribe.ts exports transcribeAudio, isTranscriptionAvailable
- src/media/retry.ts exports withRetry, isTransientError
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-multimodal/06-01-SUMMARY.md`
</output>
```
